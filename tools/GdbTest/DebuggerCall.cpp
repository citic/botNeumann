#include "DebuggerCall.h"
#include <QSocketNotifier>

static const QString gdbPath = QStringLiteral(
#ifdef Q_OS_MAC
	"/opt/local/bin/ggdb");
#else
	"gdb");
#endif

DebuggerCall::DebuggerCall(QObject *parent)
	: ToolCall("DebuggerCall", parent)
{
	createPseudoterminal();
}

DebuggerCall::~DebuggerCall()
{
	// Exit gdb cleanly
	printf("%s: exiting gdb...\n", qPrintable(toolName));
	process.write("-gdb-exit\n");
	process.terminate();
	process.waitForFinished();
}

bool DebuggerCall::start()
{
	const QString& command = QStringLiteral("%1 -q --interpreter=mi2").arg(gdbPath);
	printf("%s: starting: %s\n", qPrintable(toolName), qPrintable(command));
	process.start(command);
	process.waitForStarted();
	return process.state() != QProcess::NotRunning;
}

#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
bool DebuggerCall::createPseudoterminal()
{
	// Open an unused pseudoterminal master device, identifed by the returned file descriptor
	// O_RDWR: open device for both reading and writing
	// O_NOCTTY: ask the pseudoterminal do not control the debugger or user program, we will do it
	pseudoterminalDeviceFileDescriptor = posix_openpt(O_RDWR | O_NOCTTY);

	// Tell to OS that this process is the owner of the pseudoterminal, and we need to read and
	// write permissions over the file descriptor. This step is unncessary on modern OSs, but it
	// is good practice to keep it for compatibility
	if( grantpt(pseudoterminalDeviceFileDescriptor) != EXIT_SUCCESS )
	{
		fprintf(stderr, "GdbTest: Failed to grant pseudoterminal %i\n", pseudoterminalDeviceFileDescriptor);
		close(pseudoterminalDeviceFileDescriptor);
		return false;
	}

	// New pseudoterminals are locked by default, in order  perform whatever initialization before
	// programs start running on it. When initialization is done, pseudoterminal must be unlocked
	if( unlockpt(pseudoterminalDeviceFileDescriptor) != EXIT_SUCCESS )
	{
		fprintf(stderr, "GdbTest: Failed to unlock pseudoterminal %i\n", pseudoterminalDeviceFileDescriptor);
		close(pseudoterminalDeviceFileDescriptor);
		return false;
	}

	// If the pseudoterminal was created successfully, it will have a name like /dev/pts/nn where
	// nn is a number that identifies the pseudoterminal
	printf("GdbTest: using pseudoterminal: %s\n", ptsname(pseudoterminalDeviceFileDescriptor));
	return true;
}

void DebuggerCall::startMonitoringPseudoterminal()
{
	// QSocketNotifier monitors activity on a file descriptor
	this->pseudoterminalActivityMonitor = new QSocketNotifier(pseudoterminalDeviceFileDescriptor, QSocketNotifier::Read);
	// Read any output generated by GDB
	connect(this->pseudoterminalActivityMonitor, SIGNAL(activated(int)), this, SLOT(onGdbOutput(int)));
}

void DebuggerCall::onGdbOutput(int fileDescriptor)
{
	// Gdb generated output
	Q_UNUSED(fileDescriptor);

	// Read output generated by GDB
	char buffer[128];
	int n = read( this->pseudoterminalDeviceFileDescriptor, buffer, sizeof(buffer) - 1 );

	// If output was read successfully
	if(n > 0)
		buffer[n] = '\0';

	// For now
	printf("gdb:'%s'\n", buffer);
}
