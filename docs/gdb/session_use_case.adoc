= Interaction botNeumann - GDB, session example
:toc:
:toclevels: 3

This document explains how botNeumann gets information from the player's solution executable running under GDB, and how that information is used to produce the visualization.
This is considered the "big-picture" algorithm to produce the visualization.

This document is sliced in sections.
Most section titles are the commands sent to https://sourceware.org/gdb/onlinedocs/gdb/GDB_002fMI.html[GDB Machine Interface].
The response generated by GDB to the command is immediately included after the section title as code sections.
An optional description of actions made by botNeumann is included as normal text.

This example session was built running `tools/examples/all_inclusive/alli.cpp`.
A shorter path `/tmp/alli/` is used instead to make output more readable.
"All inclusive" is a convoluted program trying to apply many C and C++ features.
Its goal is to predict how botNeumann would behave running unpredicable users' code.
Internally, `alli.cpp` considers any input (arguments and standard input) as arguments, convert them to lowercase, and print them alphabetically sorted to the standard output.
In order to reproduce this example, go before to the `tools/examples/all_inclusive` folder and run `make` to get `alli` executable and the symbols file `bn_tags.txt`.




== 1. Preparation


==== $ gdb -q -i mi

	=thread-group-added,id="i1"
	(gdb)

Start a new GDB session using Machine Interface (MI).


==== -file-exec-and-symbols "/tmp/alli/alli"

	^done
	(gdb)

Provide the path and name for executable. It may be included in the previous GDB call altenatively.


==== -exec-arguments "3" < "/tmp/alli/bn_01_input.txt" > "/tmp/alli/bn_01_output_ps.txt" 2> "/tmp/alli/bn_01_error_ps.txt"

	^done
	(gdb)

. Generate test cases from .botnu unit
. Start visualization with one of them, this example runs test case 01
. Convert contents of `/tmp/alli/bn_01_args.txt` to a space-separated string `args`
. Include `args` as the first arguments, in this case is `"3"`
. If Unix-like OS: redirect standard input, output and error as shown


=== User-defined breakpoints

#### -break-insert "alli.cpp:111"

	^done,bkpt={number="1",type="breakpoint",disp="keep",enabled="y",addr="0x0000000000401de7",func="read_arguments(unsigned long long)",file="alli.cpp",fullname="/home/jhc/dev/botNeumann/tools/examples/all_inclusive/alli.cpp",line="111",thread-groups=["i1"],times="0",original-location="alli.cpp:111"}
	(gdb)

#### -break-insert "alli.cpp:64"

	^done,bkpt={number="2",type="breakpoint",disp="keep",enabled="y",addr="0x00000000004027c3",func="InputArgument::InputArgument(unsigned long long, char const*)",file="alli.cpp",fullname="/home/jhc/dev/botNeumann/tools/examples/all_inclusive/alli.cpp",line="64",thread-groups=["i1"],times="0",original-location="alli.cpp:64"}
	(gdb)

Set all user-defined breakpoints

. Collect user breakpoints from code editors
. Send them to GDB
. Create `DebuggerBreakpoint` objects with role `userDefined`
. Add breakpoints to array using breakpoint number as index: `breakpoints[b->number] = b`


=== Function definition breakpoints

==== -break-insert "alli.cpp:38"

	^done,bkpt={number="3",type="breakpoint",disp="keep",enabled="y",addr="0x0000000000402b0e",func="AbstractArgument<char const*>::AbstractArgument(unsigned long long, char const*)",file="alli.cpp",fullname="/home/jhc/dev/botNeumann/tools/examples/all_inclusive/alli.cpp",line="38",thread-groups=["i1"],times="0",original-location="alli.cpp:38"}
	(gdb)


Similar output with remaining breakpoints:

	-break-insert "alli.cpp:44"
	-break-insert "alli.cpp:45"
	-break-insert "alli.cpp:51"
	-break-insert "alli.cpp:64" (skipped)
	-break-insert "alli.cpp:71"
	-break-insert "alli.cpp:76"
	-break-insert "alli.cpp:81"
	-break-insert "alli.cpp:86"
	-break-insert "alli.cpp:91"
	-break-insert "alli.cpp:104"
	-break-insert "alli.cpp:121"
	-break-insert "alli.cpp:128"
	-break-insert "alli.cpp:135"
	-break-insert "alli.cpp:140"
	-break-insert "alli.cpp:149"
	-break-insert "alli.cpp:162"


Set breakpoints for all functions in player's solution. When these breakpoints are triggered, a function call will be animated.

. Extract function names with Universal ctags (Exuberant ctags does not support C++11). This step is made in the building state.
. For each function definition in `bn_tags.txt`, set a breakpoint
. For each breakpoint response, create a `DebuggerBreakpoint` object with role `functionBody`
. Add the breakpoint to the breakpoints[] array in its respective position
. If there already is a `userDefined` breakpoint at the same file:line, do not duplicate it, just add the role `functionBody` to the existing one. (Otherwise, GDB will remove the second one later).

Deprecated:

	-interpreter-exec console "rbreak alli.cpp:."

GDB recursive breakpoints may fail for unclear reasons, e.g: "mismatched quote"




== 2. Start player solution (program entry point)


==== -exec-run --start


[source,js]
----
	=breakpoint-created,bkpt={number="19",type="breakpoint",disp="del",enabled="y",addr="0x000000000040219e",func="main(int, char**)",file="alli.cpp",fullname="/home/jhc/dev/botNeumann/tools/examples/all_inclusive/alli.cpp",line="163",thread-groups=["i1"],times="0",original-location="main"}

	=thread-group-started,id="i1",pid="4995"

	=thread-created,id="1",group-id="i1"

	=library-loaded,id="/lib64/ld-linux-x86-64.so.2",target-name="/lib64/ld-linux-x86-64.so.2",host-name="/lib64/ld-linux-x86-64.so.2",symbols-loaded="0",thread-group="i1"

	^running

	*running,thread-id="all"

	(gdb)

	=library-loaded,id="/usr/lib/x86_64-linux-gnu/libstdc++.so.6",target-name="/usr/lib/x86_64-linux-gnu/libstdc++.so.6",host-name="/usr/lib/x86_64-linux-gnu/libstdc++.so.6",symbols-loaded="0",thread-group="i1"

	=library-loaded,id="/lib/x86_64-linux-gnu/libgcc_s.so.1",target-name="/lib/x86_64-linux-gnu/libgcc_s.so.1",host-name="/lib/x86_64-linux-gnu/libgcc_s.so.1",symbols-loaded="0",thread-group="i1"

	=library-loaded,id="/lib/x86_64-linux-gnu/libpthread.so.0",target-name="/lib/x86_64-linux-gnu/libpthread.so.0",host-name="/lib/x86_64-linux-gnu/libpthread.so.0",symbols-loaded="0",thread-group="i1"

	=library-loaded,id="/lib/x86_64-linux-gnu/libc.so.6",target-name="/lib/x86_64-linux-gnu/libc.so.6",host-name="/lib/x86_64-linux-gnu/libc.so.6",symbols-loaded="0",thread-group="i1"

	=library-loaded,id="/lib/x86_64-linux-gnu/libm.so.6",target-name="/lib/x86_64-linux-gnu/libm.so.6",host-name="/lib/x86_64-linux-gnu/libm.so.6",symbols-loaded="0",thread-group="i1"

	~"[Thread debugging using libthread_db enabled]\n"

	~"Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\n"

	=breakpoint-modified,bkpt={number="2",type="breakpoint",disp="keep",enabled="y",addr="0x00000000004027c3",func="InputArgument::InputArgument(unsigned long long, char const*)",file="alli.cpp",fullname="/home/jhc/dev/botNeumann/tools/examples/all_inclusive/alli.cpp",line="64",thread-groups=["i1"],times="1",original-location="alli.cpp:64"}

	~"\n"

	~"Breakpoint 2, InputArgument::InputArgument (this=0x60b580 <global_program_name>, number=0, value=0x406dc6 \"all_inclusive\") at alli.cpp:64\n"

	~"64\t\tInputArgument(ull number, const char* value)\n"

	*stopped,reason="breakpoint-hit",disp="keep",bkptno="2",frame={addr="0x00000000004027c3",func="InputArgument::InputArgument",args=[{name="this",value="0x60b580 <global_program_name>"},{name="number",value="0"},{name="value",value="0x406dc6 \"all_inclusive\""}],file="alli.cpp",fullname="/home/jhc/dev/botNeumann/tools/examples/all_inclusive/alli.cpp",line="64"},thread-id="1",stopped-threads="all",core="6"

	(gdb)
----


Start the execution of inferior and stop in the program entry point

. Set Visualization in `elaboration` mode.
. `=breakpoint-created`: Breapoint at program's entry point. Create object and it to breakpoints[]. If another breakpoint already exists at the same file:line, add the role `functionBody` to it. Notice: the breakpoint is added to the `breakpoints[]` array unconditionally.
. `=thread-group-started`: Collect the process id from `pid` param.
. `=thread-created`: Animate creation of main thread when. Do <<create-execution-thread>>
. `=library-loaded`: Ignore all library load responses. Optional: trace `libc` load and store a flag it is being used.
. `*running`: Change inferior state to *running
. `=breakpoint-modified`. Update breakpoint
. `*stopped,reason="breakpoint-hit"`. Execution stopped at program entry point. If visualization in `elaboration` mode (true), do NOT do <<breakpoint-hit>> yet. Store the result tree for later user. Continue as usual (through next section).
. If there are removed breakpoints: Remove deleted breakpoint from breakpoints[] array
  Breakpoint was likely removed because there is other breakpoint at the same line.



=== 2.1 Dynamic memory breakpoints


==== -break-insert -f __libc_malloc

	^done,bkpt={number="20",type="breakpoint",disp="keep",enabled="y",addr="0x00007ffff72dc580",func="__GI___libc_malloc",file="malloc.c",fullname="/build/glibc-Qz8a69/glibc-2.23/malloc/malloc.c",line="2900",thread-groups=["i1"],times="0",original-location="__libc_malloc"}
	(gdb)

Set breakpoint for the dynamic memory management functions. These breakpoints are set after the libc library has been loaded.

. Set break to stop inferior each time dynamic memory is allocated
. Create a DebuggerBreakpoint with role `mallocCall` and add to `breakpoints[]` array
. Future work: check if it works with GCC/MinGW for MsWin


==== -break-insert -f __libc_calloc

	^done,bkpt={number="21",type="breakpoint",disp="keep",enabled="y",addr="0x00007ffff72dd160",func="__libc_calloc",file="malloc.c",fullname="/build/glibc-Qz8a69/glibc-2.23/malloc/malloc.c",line="3170",thread-groups=["i1"],times="0",original-location="__libc_calloc"}
	(gdb)

. Set break to stop inferior each time initialized dynamic memory is allocated
. Create a `DebuggerBreakpoint` with role `callocCall` and add to `breakpoints[]` array



==== -break-insert -f __libc_realloc

	^done,bkpt={number="22",type="breakpoint",disp="keep",enabled="y",addr="0x00007ffff72dcb10",func="__GI___libc_realloc",file="malloc.c",fullname="/build/glibc-Qz8a69/glibc-2.23/malloc/malloc.c",line="2972",thread-groups=["i1"],times="0",original-location="__libc_realloc"}
	(gdb)

. Set break to stop inferior each time dynamic memory is re-allocated
. Create a `DebuggerBreakpoint` with role `reallocCall` and add to `breakpoints[]` array


==== -break-insert -f __libc_free

	^done,bkpt={number="23",type="breakpoint",disp="keep",enabled="y",addr="0x00007ffff72dc940",func="__GI___libc_free",file="malloc.c",fullname="/build/glibc-Qz8a69/glibc-2.23/malloc/malloc.c",line="2932",thread-groups=["i1"],times="0",original-location="__libc_free"}
	(gdb)

. Set break to stop inferior each time dynamic memory is de-allocated
. Create a `DebuggerBreakpoint` with role `freeCall` and add to `breakpoints[]` array



=== 2.2 Watch standard input/output


==== -var-create bn_io_stdin @ stdin->_IO_read_ptr

	^done,name="bn_io_stdin",numchild="1",value="0x0",type="char *",has_more="0"
	(gdb)

. In Unix: Create object variables watching changes in IO, using notation `bn_io_iofile`
. Future work: check if it works with GCC/MinGW for MsWin


==== -var-create bn_io_stdout @ stdout->_IO_write_ptr

	^done,name="bn_io_stdout",numchild="1",value="0x0",type="char *",has_more="0"
	(gdb)



==== -var-create bn_io_stderr @ stderr->_IO_write_ptr

	^done,name="bn_io_stderr",numchild="1",value="0x0",type="char *",has_more="0"
	(gdb)



==== -data-evaluate-expression bn_reopen_stdin()

	^done,value="{_flags = -72540024, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x0, _fileno = 0, _flags2 = 0, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 '\\000', _shortbuf = \"\", _lock = 0x7ffff7bb6790 <_IO_stdfile_0_lock>, _offset = -1, _codecvt = 0x0, _wide_data = 0x7ffff7bb49c0 <_IO_wide_data_0>, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = '\\000' <repeats 19 times>}"
	(gdb)

Only in MsWin: redirect stdin. Do the same for stdout and stderr: `-data-evaluate-expression bn_reopen_stdout()`, `-data-evaluate-expression bn_reopen_stderr()`



=== 2.3 Watch global variables


==== -var-create bn_gv_1 @ global_variable_name_1

. Get global variables from `PlayerSolution` (collected with ctags in building process in file `bn_tags.txt`).
. For each global variable, create a GDB-variable object with name `bn_gv_num`
. Create a DebuggerVariable object and load it from GDB response
. Add the DebuggerVariable to the VariableManager
. Animate variable creation in DataSegment and init it with the value obtained from GDB response
. Future work: detect static local variables

The list of all variables for "all inclusive" example:

....
	-var-create bn_gv_1 @ all_arguments

	^done,name="bn_gv_1",numchild="1",value="{...}",type="std::vector<InputArgument*, std::allocator<InputArgument*> >",has_more="0"

	-var-create bn_gv_2 @ buffer
	^done,name="bn_gv_2",numchild="1",value="0x0",type="char **",has_more="0"
	(gdb)

	-var-create bn_gv_3 @ input_count
	^done,name="bn_gv_3",numchild="0",value="0",type="ull",has_more="0"
	(gdb)

	-var-create bn_gv_4 @ sorted_arguments
	^done,name="bn_gv_4",numchild="1",value="0x0",type="InputArgument **",has_more="0"
	(gdb)

	-var-create bn_gv_5 @ sorted_count
	^done,name="bn_gv_5",numchild="0",value="0",type="size_t",has_more="0"
	(gdb)

	-var-create bn_gv_6 @ global_program_name
	^done,name="bn_gv_6",numchild="2",value="{...}",type="InputArgument",has_more="0"
	(gdb)
....


Do <<variable-info>> to get data types and sizes. Example with vector `all_arguments`:

	-data-evaluate-expression sizeof(all_arguments)
	^done,value="24"
	(gdb)

	-interpreter-exec console "ptype /mt all_arguments"
	&"Python Exception <class 'gdb.error'> No type named InputArgument*.: \n"
	~"type = class std::vector<InputArgument*, std::allocator<InputArgument*> > [with _Tp = InputArgument *, _Alloc = std::allocator<InputArgument*>] : protected std::_Vector_base<InputArgument*, _Alloc> {\n"
	~"}\n"
	^done
	(gdb)


Example with typdef `input_count`:

	-data-evaluate-expression sizeof(input_count)
	^done,value="8"
	(gdb)

	-interpreter-exec console "ptype /mt input_count"
	~"type = unsigned long long\n"
	^done
	(gdb)

Example with size_t `sorted_count`:

	-data-evaluate-expression sizeof(sorted_count)
	^done,value="8"
	(gdb)

	-interpreter-exec console "ptype /mt sorted_count"
	~"type = unsigned long\n"
	^done
	(gdb)

Example with object:

	-data-evaluate-expression sizeof(global_program_name)
	^done,value="56"
	(gdb)

	-interpreter-exec console "ptype /mt global_program_name"
	~"type = class InputArgument : public AbstractArgument<char const*> {\n"
	~"  protected:\n"
	~"    std::__cxx11::string value2;\n"
	~"}\n"
	^done
	(gdb)



=== 2.4 Load standard input

. Create characters for the test case's standard input
. Animate characters arriving by the tube until reaching the left edge



=== 2.5 Finish elaboration phase

. Set visualization's elaboration mode to false (or use another state: loading).
. Do <<breakpoint-hit>> using the stored tree of *stopped response.



== 3. Execution threads



[[create-execution-thread]]
=== 3.1 Create execution thread

Each time `=thread-created,id="#"` is issued, create an `ExecutionThread` object. If there is an idle processor core, animate a robot appearing in the core with no line number. Ask gdb:

* `-thread-info`
* `-stack-info-depth`


==== -thread-info

For main thread:

	^done,threads=[{id="1",target-id="Thread 0x7ffff7fc9740 (LWP 4995)",name="alli",frame={level="0",addr="0x00000000004027c3",func="InputArgument::InputArgument",args=[{name="this",value="0x60b580 <global_program_name>"},{name="number",value="0"},{name="value",value="0x406dc6 \"all_inclusive\""}],file="alli.cpp",fullname="/home/jhc/dev/botNeumann/tools/examples/all_inclusive/alli.cpp",line="64"},state="stopped",core="6"}],current-thread-id="1"
	(gdb)

. Locate the `ExecutionThread` with the given id, and make it to update its fields. (Be sure to store the `level` field).
. If there is a line number change, animate it on the robot, and highlight line in code segment (may require to load another file in code editor).
. If `executionThread.callStack.isEmpty()` and `thread-info/frame/file` is not in player solution: animate a function call with an empty frame, because it will not have a breakpoint-hit.


==== -stack-info-depth
All threads? or ` --thread 1`

	^done,depth="6"
	(gdb)

. Update the `ExecutionThread::callStackDepth` integer value (init value -1). If decreased animate a <<function-return>>.



=== 3.2 Remove execution thread


Each time `=thread-exited,id=#` is issued:

. Locate the ExecutionThread with given id and ask to remove.
. If thread has a cpu core assigned, remove thread from cpu core
. Remove thread from the scene, including its hidden or visible call stack
. Remove thread memory from CpuCores::executionThreads[] array



[[breakpoint-hit]]
== 4. Breakpoint hit

Player solution (inferior) stopped for hitting a breakpoint. Get the `/bkptno` integer value, and find the `DebuggerBreakpoint` object. If breakpoint object has one or more roles:

* `functionBody`: Do <<function-call>> (also for `programEntryPoint`).
* `userDefined`: Do <<user-defined-breakpoint>>.
* `mallocCalled`: Process memory allocation (uninitialized)
* `callocCalled`: Process memory allocation (initialized)
* `reallocCalled`: Process memory reallocation
* `freeCalled`: Process memory deallocation
* `newObject`: ToDo:
* `newArray`: ToDo:
* `deleteObject`: ToDo:
* `deleteArray`: ToDo:



[[function-call]]
=== 4.1 Function call

Example at program's entry point:

	*stopped,reason="breakpoint-hit",disp="keep",bkptno="2",frame={addr="0x00000000004027c3",func="InputArgument::InputArgument",args=[{name="this",value="0x60b580 <global_program_name>"},{name="number",value="0"},{name="value",value="0x406dc6 \"all_inclusive\""}],file="alli.cpp",fullname="/home/jhc/dev/botNeumann/tools/examples/all_inclusive/alli.cpp",line="64"},thread-id="1",stopped-threads="all",core="6"
	(gdb)


Player solution hit a breakpoint that has the role of `functionCall`. The breakpoint must be at the beginning of the body of a function in a file that is part of player solution.

. Get the `/thread-id="#"` from `*stopped` response, locate the `ExecutionThread` object.
. [ToDo: check call stack depth? If there is not an increase in the level, stop animation.] [Edit: unnecessary for entry point, at least]
. If `ExecutionThread` is active (has an assigned CPU core), animate the door opening in its CPU core.
. Build a memory frame for the new stack frame with the function name (`/frame/func`) in the roof. By default, memory frames are filled of garbage.
. Raise the memory roof to the CPU core door, to make the roof visible only. Arguments and variables will be made visible next.
. ToDo: If execution thread is idle in visualization (does not have an assigned CPU core), it should be stopped at inferior through GDB, to avoid it generating more responses.


==== -stack-list-arguments 2 0 0

	^done,stack-args=[frame={level="0",args=[{name="this",type="InputArgument * const",value="0x60b580 <global_program_name>"},{name="number",type="ull",value="0"},{name="value",type="const char *",value="0x406dc6 \"all_inclusive\""}]}]
	(gdb)


. The `0 0` argument is for selecting top frame only: `/frame/level == 0`
. Calculate the size required for all parameters, and the number required memory rows with garbage. Do <<variable-info>>

. Raise the min(required memory rows, max allowed stack frame size/rowsize) rows and stop
. Create all variables in the memory rows
. If there is overflow, animate a stack overflow (see Program termination)
. Initialize each parameter with the argument, they will replace the garbage

. Create variables for arguments, not initialized yet.
. Initialize arguments (set arguments' values)
. Create unitialized and initialized variables
. Raise the stack frame to make visible last variable


==== -stack-list-locals 2

	^done,locals=[{name="n",type="size_t",value="4196304"},{name="grid",type="char **",value="0x7fffffffdf50"},{name="error",type="int",value="0"}]
	(gdb)

. Do the same than arguments, but some values may be unitialized (keep their garbage)
. Add the "memory frame legs" to the last memory row


==== -stack-info-depth

	^done,depth="2"
	(gdb)

. Check if it matches the number of stack frames
. Update the ExecutionThread::callStackDepth integer value.



[[variable-info]]
=== 4.2 Get variable info

Does GDB/MI offer a method to get data-type size or unroll data types? We use C/C++ expressions and normal user interface:

==== -data-evaluate-expression sizeof(this)

	^done,value="8"
	(gdb)

Get the size in bytes of a variable. It may not match the Botnu architecture (32 or 64bits).


==== -interpreter-exec console "ptype /mt this"

	~"type = class InputArgument : public AbstractArgument<char const*> {\n"
	~"  protected:\n"
	~"    std::__cxx11::string value2;\n"
	~"} * const\n"
	^done
	(gdb)


Example with primitive type:

	-data-evaluate-expression sizeof(number)
	^done,value="8"
	(gdb)

	-interpreter-exec console "ptype /mt number"
	~"type = unsigned long long\n"
	^done
	(gdb)


Example with pointer to primitive:

	-data-evaluate-expression sizeof(value)
	^done,value="8"
	(gdb)

	-interpreter-exec console "ptype /mt value"
	~"type = const char *\n"
	^done
	(gdb)


[[user-defined-breakpoint]]
=== 4.3 User defined breakpoint

. Change visualization state to `paused`.
. Set VisualizationSpeed::seeking to false
. When debugger enters in idle state, no more `exec-next` commands will be automatically sent.
. Execution will continue when user presses the resume button or the step button.



=== 4.4 Dynamic memory management breakpoint


The execution stopped at a breakpoint set to a dynamic memory management function. The call may be done for the player solution directly or indirectly for any library function called by player. Eg:

	char* buffer = (char*) malloc(1024); // explicit call to malloc
	Fraction* fractions = new Fraction[10]; // explicit call to new[]
	printf("Average = %lf", average); // implicit call to malloc

Explicit calls are always reflected in the animation. Implicit calls sometimes may be reflected in the visualization. The way we determine the function call should or not be animated, is storing information about the call, and use this information later to know if some user variable was modified (a GDB variable-object changed).

==== [e.g:] -exec-next

	^running
	*running,thread-id="all"
	(gdb)
	=breakpoint-modified,bkpt={number="13",type="breakpoint",disp="keep",enabled="y",addr="0x00007ffff7874580",func="__GI___libc_malloc",file="malloc.c",fullname="/build/glibc-Qz8a69/glibc-2.23/malloc/malloc.c",line="2900",thread-groups=["i1"],times="1",original-location="__libc_malloc"}

	~"\n"

	~"Breakpoint 13, __GI___libc_malloc (bytes=4096) at malloc.c:2900\n"
	&"2900\tmalloc.c: No such file or directory.\n"
	*stopped,reason="breakpoint-hit",disp="keep",bkptno="13",frame={addr="0x00007ffff7874580",func="__GI___libc_malloc",args=[{name="bytes",value="4096"}],file="malloc.c",fullname="/build/glibc-Qz8a69/glibc-2.23/malloc/malloc.c",line="2900"},thread-id="1",stopped-threads="all",core="0"
	(gdb)


. Create an object with the following information

	class DynamicMemoryBlock
	{
		enum functionCalled; // malloc/calloc/realloc/free/new/new[]/delete/delete[]
		size_t size; // from value of frame/args/bytes
		void* address; // from return value
	}

. Store the object in HeapSegment::dynamicMemoryBlocks[] (or VariableManager::?)


==== -exec-finish

	^running
	*running,thread-id="all"
	(gdb)
	*stopped,reason="function-finished",frame={addr="0x00007ffff785e1d5",func="__GI__IO_file_doallocate",args=[{name="fp",value="0x7ffff7bb48e0 <_IO_2_1_stdin_>"}],file="filedoalloc.c",fullname="/build/glibc-Qz8a69/glibc-2.23/libio/filedoalloc.c",line="127"},gdb-result-var="$1",return-value="(void *) 0x603010",thread-id="1",stopped-threads="all",core="1"
	(gdb)

We are not interested in debugging the body of the library's memory function. We force the function to return. From /return-value"(void *) addr" we get the return address.

	dynamicMemoryBlock.address = extractAddressFrom( tree.valueOf("/return-value") );



==== -stack-info-depth

	^done,depth="8"
	(gdb)

We need to go back to the player's code where the execution thread was running. I have not had luck with `step` (in not debugging code) or `until` commands. As a workaround, ask for the number of functions running on the call stack of the execution thread (in previous example, currentLevel=8). We know the level of the returning point in ExecutionThread::callStack.level (returnToLevel). Simply ask `-exec-finish` to GDB `currentLevel - returnToLevel` times, until the returnToLevel has been reahed, and ignore their results.


* `-exec-finish`
* `-stack-info-depth`

When finally arrived to the player's function before the dynamic memory function was stopped by breakpoint, we can decide if an animation must be produced or not:


==== -var-update --all-values *

	^done,changelist=[]
	(gdb)

. If some variable-object changed its value to dynamicMemoryBlock.address an animation must be done.
. If the distance between the player's function and the dynamic memory function stopped is 1 (or 2?)
  the player directly called the memory management function, and an animation must be done.
. Otherwise, animation is skipped and the DynamicMemoryBlock object can be deleted.

If an animation must be done:
. Pass the DynamicMemoryBlock to the HeapSegment object
. If block was allocated:

	- Look for the first empty space larger or equal than block.size
	- Fet the pointed data type (from gdb info?)
	- Animate allocation of size/sizeof(data_type) values
	- If values were allocated with malloc, keep garbage, otherwise, try to init using gdb values
	- If there is not enough space, animate segmentation fault (see Program termination)
	- (Else) Update the pointer that changed in changelist[] from -var-update command

If block was deallocated:

	- Look for the corresponding memory allocation block, if not found, animate segmentation fault
	- If the operator for deallocating matches the operator used for allocation (xalloc-free,
	  new-delete, new[]-delete[]), remove block.size bytes from heap and remove blocks
	- (Else) Animate removal of one object (ToDo: study removing delete[] to single object)

If block was reallocated (i.e. using realloc)

	- If the address is nullptr, nothing was re-allocated, and ignore the event
	- If the address is the same and size is 0, act as a call to free() [?]
	- If the address is the same and size is smaller than the previous, shrink data
	- If the address is not null and size is larger than the previous, look for enough free space
	  in HeapSegment. Act as a normal allocation (malloc, not calloc). If not segmentation fault,
	  finally act as deallocation (free) of the previous address.




== 5. Execution loop


Each step of this loop is considered a step of the visualization. When visualization is paused and player presses the `Step` button, one *visualization step* is done (animated). When visualization is in seeking state, a visualization step is issued each time there is no pending commands to be sent to GDB.


==== -stack-info-depth

	^done,depth="6"
	(gdb)

. Update the `ExecutionThread::callStackDepth` integer value (init value -1). If decreased animate a <<function-return>>.


==== -stack-list-variables 2

	^done,variables=[{name="n",type="size_t",value="4196304"},{name="grid",type="char **",value="0x7fffffffdf50"},{name="error",type="int",value="0"}]
	(gdb)

Update local variables

. Get the value of all the local variables, and pass them to the CallStack or VariableManager
. If some variable has changed its value, animate it
. ToDo: If we create variable-objects for each local variable in all threads, this comparison
  step may be not necessary
. ToDo: GDB consider local static variables as normal local variables. We have to separe them



==== -var-update --all-values *

	^done,changelist=[]
	(gdb)

Update global variables and standard input/output streams

. If no variables have changed their values, done
. If a global variable changed its value, pass the message to the DataSegment, and animate change
. If a standard input/output stream changed its value, replace FILE for the stream and issue:


==== -data-evaluate-expression bn_tell_FILE()

	[ToDo]
	$1 = 2

. Capture the number of bytes moved
. If FILE is stdin, animate Robot consuming n chars from stdin (robot turns)
  Locate what variable received the read input (it should be included in -var-update result)
  Animate robot converting to the data type of the changed variable
  If no target variable is found, animate robot discarding the read bytes
. If FILE is stdout, it is so difficult to determine which variables were involved to produce the
  output. Animate the robot building the output message and sending it by the stdout. Check if output matches expected output and turn on/off the output tester accordingly.
. If file is stderr, ToDo: ignore the event, for now
. ToDo: provide more tubes for user own files (FILE*, std::istream, std::fstream...)



==== -exec-next

	^running
	*running,thread-id="all"
	(gdb)
	*stopped,reason="end-stepping-range",frame={addr="0x00000000004008dd",func="main",args=[],file="solution.c",fullname="/home/jhc/dev/programmingexercises/1.5_pointer_arrays/tictactoe_nxn/solution.c",line="14"},thread-id="1",stopped-threads="all",core="7"
	(gdb)

The _visualization step_ finished executing the next instruction.
Just act according to the response as stated in previous sections.



[[function-return]]
=== Function return

. Animate stack frame being dropped through the cpu core's memory interface



== 6. Program termination (visualization stop)

Program may terminate for these reasons:

. Player stopped visualization
. Program finished normally
. Program received a signal from OS (eg: segmentation fault)
. Program failed to run in the virtualized environment (unit) (eg: stack overflow)


If player stopped visualization or program failed to run in the constrained environmentof the unit, stop inferior execution:

==== -exec-interrupt

	^done
	(gdb)


. Stop gdb also?:

==== -gdb-exit

	^exit
	=thread-exited,id="1",group-id="i1"
	=thread-group-exited,id="i1"


If inferior was finished normally or by a signal, GDB will stop it and emit a *stopped async record. The reasons may be:

* exited: The inferior exited.
* exited-normally: The inferior exited normally.
* signal-received: A signal was received by the inferior.

Provide some feedback to user. Stop the visualization and move to state inferior-exited, where only Stop button is enable. When user presses it, visualization returns to editing state.




== A. Miscellaneous commands (reference)


==== -thread-info

	^done,threads=[{id="1",target-id="Thread 0x7ffff7fcc700 (LWP 23146)",name="solution",frame={level="0",addr="0x00007ffff7874580",func="__GI___libc_malloc",args=[{name="bytes",value="4096"}],file="malloc.c",fullname="/build/glibc-Qz8a69/glibc-2.23/malloc/malloc.c",line="2900"},state="stopped",core="0"}],current-thread-id="1"
	(gdb)



==== -stack-list-frames

	^done,stack=[frame={level="0",addr="0x00007ffff7874580",func="__GI___libc_malloc",file="malloc.c",fullname="/build/glibc-Qz8a69/glibc-2.23/malloc/malloc.c",line="2900"},frame={level="1",addr="0x00007ffff785e1d5",func="__GI__IO_file_doallocate",file="filedoalloc.c",fullname="/build/glibc-Qz8a69/glibc-2.23/libio/filedoalloc.c",line="127"},frame={level="2",addr="0x00007ffff786c594",func="__GI__IO_doallocbuf",file="genops.c",fullname="/build/glibc-Qz8a69/glibc-2.23/libio/genops.c",line="398"},frame={level="3",addr="0x00007ffff786b69c",func="_IO_new_file_underflow",file="fileops.c",fullname="/build/glibc-Qz8a69/glibc-2.23/libio/fileops.c",line="556"},frame={level="4",addr="0x00007ffff786c60e",func="__GI__IO_default_uflow",file="genops.c",fullname="/build/glibc-Qz8a69/glibc-2.23/libio/genops.c",line="413"},frame={level="5",addr="0x00007ffff784d260",func="_IO_vfscanf_internal",file="vfscanf.c",fullname="/build/glibc-Qz8a69/glibc-2.23/stdio-common/vfscanf.c",line="634"},frame={level="6",addr="0x00007ffff785c5df",func="__isoc99_scanf",file="isoc99_scanf.c",fullname="/build/glibc-Qz8a69/glibc-2.23/stdio-common/isoc99_scanf.c",line="37"},frame={level="7",addr="0x00000000004008fb",func="main",file="solution.c",fullname="/home/jhc/dev/programmingexercises/1.5_pointer_arrays/tictactoe_nxn/solution.c",line="15"}]
	(gdb)



==== -exec-until solution.c:15

	^running
	*running,thread-id="all"
	(gdb)
	*stopped,reason="location-reached",frame={addr="0x00007ffff786b69c",func="_IO_new_file_underflow",args=[{name="fp",value="0x7ffff7bb48e0 <_IO_2_1_stdin_>"}],file="fileops.c",fullname="/build/glibc-Qz8a69/glibc-2.23/libio/fileops.c",line="556"},thread-id="1",stopped-threads="all",core="2"
	(gdb)
