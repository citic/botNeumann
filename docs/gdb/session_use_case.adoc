= Interaction botNeumann - GDB, session example
:toc:
:toclevels: 3

This document explains how botNeumann gets information from the player's solution executable running under GDB, and how that information is used to produce the visualization.
This is considered the "big-picture" algorithm to produce the visualization.

This document is sliced in sections.
Most section titles are the commands sent to https://sourceware.org/gdb/onlinedocs/gdb/GDB_002fMI.html[GDB Machine Interface].
The response generated by GDB to the command is immediately included after the section title as code sections.
An optional description of actions made by botNeumann is included as normal text.

This example session was built running `tools/examples/all_inclusive/alli.cpp`.
A shorter path `/tmp/alli/` is used instead in order to make output more readable.
"All inclusive" is a convoluted program trying to apply many C and C++ features.
Its goal is to predict how botNeumann would behave running these features when from users' code.
Internally, `alli.cpp` considers any input (arguments and standard input) as arguments, converts them to lowercase, and prints them alphabetically sorted to the standard output.
In order to reproduce this example, go before to the `tools/examples/all_inclusive` folder and run `make` to get `alli` executable and the symbols file `bn_tags.txt`.




== 1. Preparation


==== $ gdb -q -i mi

	=thread-group-added,id="i1"
	(gdb)

Start a new GDB session using Machine Interface (MI).


==== -file-exec-and-symbols "/tmp/alli/alli"

	^done
	(gdb)

Provide the path and name for executable. It may be included in the previous GDB call altenatively.


==== -exec-arguments "3" < "/tmp/alli/bn_01_input.txt" > "/tmp/alli/bn_01_output_ps.txt" 2> "/tmp/alli/bn_01_error_ps.txt"

	^done
	(gdb)

. Generate test cases from .botnu unit
. Start visualization with one of them, this example runs test case 01
. Convert contents of `/tmp/alli/bn_01_args.txt` to a space-separated string `args`
. Include `args` as the first arguments, in this case is `"3"`
. If Unix-like OS: redirect standard input, output and error as shown


=== User-defined breakpoints

#### -break-insert "alli.cpp:111"

	^done,bkpt={number="1",type="breakpoint",disp="keep",enabled="y",addr="0x0000000000401de7",func="read_arguments(unsigned long long)",file="alli.cpp",fullname="/tmp/alli/alli.cpp",line="111",thread-groups=["i1"],times="0",original-location="alli.cpp:111"}
	(gdb)

#### -break-insert "alli.cpp:64"

	^done,bkpt={number="2",type="breakpoint",disp="keep",enabled="y",addr="0x00000000004027c3",func="InputArgument::InputArgument(unsigned long long, char const*)",file="alli.cpp",fullname="/tmp/alli/alli.cpp",line="64",thread-groups=["i1"],times="0",original-location="alli.cpp:64"}
	(gdb)

Set all user-defined breakpoints

. Collect user breakpoints from code editors
. Send them to GDB
. Create `DebuggerBreakpoint` objects with role `userDefined`
. Add breakpoints to array using breakpoint number as index: `breakpoints[b->number] = b`


=== Function definition breakpoints

==== -break-insert "alli.cpp:38"

	^done,bkpt={number="3",type="breakpoint",disp="keep",enabled="y",addr="0x0000000000402b0e",func="AbstractArgument<char const*>::AbstractArgument(unsigned long long, char const*)",file="alli.cpp",fullname="/tmp/alli/alli.cpp",line="38",thread-groups=["i1"],times="0",original-location="alli.cpp:38"}
	(gdb)


Similar output with remaining breakpoints:

	-break-insert "alli.cpp:44"
	-break-insert "alli.cpp:45"
	-break-insert "alli.cpp:51"
	-break-insert "alli.cpp:64" (skipped)
	-break-insert "alli.cpp:71"
	-break-insert "alli.cpp:76"
	-break-insert "alli.cpp:81"
	-break-insert "alli.cpp:86"
	-break-insert "alli.cpp:91"
	-break-insert "alli.cpp:104"
	-break-insert "alli.cpp:121"
	-break-insert "alli.cpp:128"
	-break-insert "alli.cpp:135"
	-break-insert "alli.cpp:140"
	-break-insert "alli.cpp:149"
	-break-insert "alli.cpp:162"


Set breakpoints for all functions in player's solution. When these breakpoints are triggered, a function call will be animated.

. Extract function names with Universal ctags (Exuberant ctags does not support C++11). This step is made in the building state.
. For each function definition in `bn_tags.txt`, set a breakpoint
. For each breakpoint response, create a `DebuggerBreakpoint` object with role `functionBody`
. Add the breakpoint to the breakpoints[] array in its respective position
. If there already is a `userDefined` breakpoint at the same file:line, do not duplicate it, just add the role `functionBody` to the existing one. (Otherwise, GDB will remove the second one later).

Deprecated:

	-interpreter-exec console "rbreak alli.cpp:."

GDB recursive breakpoints may fail for unclear reasons, e.g: "mismatched quote"




== 2. Start player solution (program entry point)


==== -exec-run --start


[source,js]
----
	=breakpoint-created,bkpt={number="19",type="breakpoint",disp="del",enabled="y",addr="0x000000000040219e",func="main(int, char**)",file="alli.cpp",fullname="/tmp/alli/alli.cpp",line="163",thread-groups=["i1"],times="0",original-location="main"}

	=thread-group-started,id="i1",pid="4995"

	=thread-created,id="1",group-id="i1"

	=library-loaded,id="/lib64/ld-linux-x86-64.so.2",target-name="/lib64/ld-linux-x86-64.so.2",host-name="/lib64/ld-linux-x86-64.so.2",symbols-loaded="0",thread-group="i1"

	^running

	*running,thread-id="all"

	(gdb)

	=library-loaded,id="/usr/lib/x86_64-linux-gnu/libstdc++.so.6",target-name="/usr/lib/x86_64-linux-gnu/libstdc++.so.6",host-name="/usr/lib/x86_64-linux-gnu/libstdc++.so.6",symbols-loaded="0",thread-group="i1"

	=library-loaded,id="/lib/x86_64-linux-gnu/libgcc_s.so.1",target-name="/lib/x86_64-linux-gnu/libgcc_s.so.1",host-name="/lib/x86_64-linux-gnu/libgcc_s.so.1",symbols-loaded="0",thread-group="i1"

	=library-loaded,id="/lib/x86_64-linux-gnu/libpthread.so.0",target-name="/lib/x86_64-linux-gnu/libpthread.so.0",host-name="/lib/x86_64-linux-gnu/libpthread.so.0",symbols-loaded="0",thread-group="i1"

	=library-loaded,id="/lib/x86_64-linux-gnu/libc.so.6",target-name="/lib/x86_64-linux-gnu/libc.so.6",host-name="/lib/x86_64-linux-gnu/libc.so.6",symbols-loaded="0",thread-group="i1"

	=library-loaded,id="/lib/x86_64-linux-gnu/libm.so.6",target-name="/lib/x86_64-linux-gnu/libm.so.6",host-name="/lib/x86_64-linux-gnu/libm.so.6",symbols-loaded="0",thread-group="i1"

	~"[Thread debugging using libthread_db enabled]\n"

	~"Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\n"

	=breakpoint-modified,bkpt={number="2",type="breakpoint",disp="keep",enabled="y",addr="0x00000000004027c3",func="InputArgument::InputArgument(unsigned long long, char const*)",file="alli.cpp",fullname="/tmp/alli/alli.cpp",line="64",thread-groups=["i1"],times="1",original-location="alli.cpp:64"}

	~"\n"

	~"Breakpoint 2, InputArgument::InputArgument (this=0x60b580 <global_program_name>, number=0, value=0x406dc6 \"all_inclusive\") at alli.cpp:64\n"

	~"64\t\tInputArgument(ull number, const char* value)\n"

	*stopped,reason="breakpoint-hit",disp="keep",bkptno="2",frame={addr="0x00000000004027c3",func="InputArgument::InputArgument",args=[{name="this",value="0x60b580 <global_program_name>"},{name="number",value="0"},{name="value",value="0x406dc6 \"all_inclusive\""}],file="alli.cpp",fullname="/tmp/alli/alli.cpp",line="64"},thread-id="1",stopped-threads="all",core="6"

	(gdb)
----


Start the execution of inferior and stop in the program entry point

. `=breakpoint-created`: Breapoint at program's entry point. Create object and it to breakpoints[]. If another breakpoint already exists at the same file:line, add the role `programEntryPoint` to it. Notice: the breakpoint is added to the `breakpoints[]` array unconditionally.
. `=thread-group-started`: Collect the process id from `pid` param.
. `=thread-created`: Animate creation of an execution thread. Do <<create-execution-thread>>
. `=library-loaded`: Ignore all library load responses. Optional: trace `libc` load and store a flag it is being used.
. `*running`: Change inferior state to *running
. `=breakpoint-modified`. Update breakpoint
. `*stopped,reason="breakpoint-hit"`. Execution stopped at program entry point. Do <<breakpoint-hit>>. It will store the result tree for later user and continue as usual.
. If there are removed breakpoints: Remove deleted breakpoint from breakpoints[] array
  Breakpoint was likely removed because there is other breakpoint at the same line.



[[set-dynamic-memory-breakpoints]]
=== 2.1 Set dynamic memory breakpoints


==== -break-insert -f __libc_malloc

	^done,bkpt={number="20",type="breakpoint",disp="keep",enabled="y",addr="0x00007ffff72dc580",func="__GI___libc_malloc",file="malloc.c",fullname="/build/glibc-Qz8a69/glibc-2.23/malloc/malloc.c",line="2900",thread-groups=["i1"],times="0",original-location="__libc_malloc"}
	(gdb)

Set breakpoint for the dynamic memory management functions. These breakpoints are set after the libc library has been loaded.

. Set break to stop inferior each time dynamic memory is allocated
. Create a DebuggerBreakpoint with role `mallocCall` and add to `breakpoints[]` array
. Future work: check if it works with GCC/MinGW for MsWin


==== -break-insert -f __libc_calloc

	^done,bkpt={number="21",type="breakpoint",disp="keep",enabled="y",addr="0x00007ffff72dd160",func="__libc_calloc",file="malloc.c",fullname="/build/glibc-Qz8a69/glibc-2.23/malloc/malloc.c",line="3170",thread-groups=["i1"],times="0",original-location="__libc_calloc"}
	(gdb)

. Set break to stop inferior each time initialized dynamic memory is allocated
. Create a `DebuggerBreakpoint` with role `callocCall` and add to `breakpoints[]` array



==== -break-insert -f __libc_realloc

	^done,bkpt={number="22",type="breakpoint",disp="keep",enabled="y",addr="0x00007ffff72dcb10",func="__GI___libc_realloc",file="malloc.c",fullname="/build/glibc-Qz8a69/glibc-2.23/malloc/malloc.c",line="2972",thread-groups=["i1"],times="0",original-location="__libc_realloc"}
	(gdb)

. Set break to stop inferior each time dynamic memory is re-allocated
. Create a `DebuggerBreakpoint` with role `reallocCall` and add to `breakpoints[]` array


==== -break-insert -f __libc_free

	^done,bkpt={number="23",type="breakpoint",disp="keep",enabled="y",addr="0x00007ffff72dc940",func="__GI___libc_free",file="malloc.c",fullname="/build/glibc-Qz8a69/glibc-2.23/malloc/malloc.c",line="2932",thread-groups=["i1"],times="0",original-location="__libc_free"}
	(gdb)

. Set break to stop inferior each time dynamic memory is de-allocated
. Create a `DebuggerBreakpoint` with role `freeCall` and add to `breakpoints[]` array


==== C++ new/delete/new[]/delete[]

Unsure if they are needed, because all of them call libc dynamic memory functions. When a libc function is called, we can ask GDB to list all function calls. We can know if the function immediatelly before is a new/delete operator, a user-defined function or any other library function. Anyway, here are the breakpoints to C++ dynamic memory operators:

	-break-insert -f "operator new"
	^done,bkpt={number="24",type="breakpoint",disp="keep",enabled="y",addr="<MULTIPLE>",times="0",original-location="operator new"},{number="24.1",enabled="y",addr="0x00000000004019c0",at="<operator new(unsigned long)@plt>",thread-groups=["i1"]},{number="24.2",enabled="y",addr="0x0000000000402597",func="operator new(unsigned long, void*)",file="/usr/include/c++/5/new",fullname="/usr/include/c++/5/new",line="130",thread-groups=["i1"]},{number="24.3",enabled="y",addr="0x00007ffff7adbc50",at="<operator new(unsigned long, std::nothrow_t const&)@plt>",thread-groups=["i1"]},{number="24.4",enabled="y",addr="0x00007ffff7adc0e0",at="<operator new(unsigned long)@plt>",thread-groups=["i1"]},{number="24.5",enabled="y",addr="0x00007ffff7ae2e60",at="<operator new(unsigned long)>",thread-groups=["i1"]},{number="24.6",enabled="y",addr="0x00007ffff7ae2ec0",at="<operator new(unsigned long, std::nothrow_t const&)>",thread-groups=["i1"]}
	(gdb)

	-break-insert -f "operator new[]"
	^done,bkpt={number="25",type="breakpoint",disp="keep",enabled="y",addr="<MULTIPLE>",times="0",original-location="operator new[]"},{number="25.1",enabled="y",addr="0x0000000000401840",at="<operator new[](unsigned long)@plt>",thread-groups=["i1"]},{number="25.2",enabled="y",addr="0x00007ffff7ae2f10",at="<operator new[](unsigned long)>",thread-groups=["i1"]},{number="25.3",enabled="y",addr="0x00007ffff7ae2f40",at="<operator new[](unsigned long, std::nothrow_t const&)>",thread-groups=["i1"]}
	(gdb)

	-break-insert -f "operator delete"
	^done,bkpt={number="26",type="breakpoint",disp="keep",enabled="y",addr="<MULTIPLE>",times="0",original-location="operator delete"},{number="26.1",enabled="y",addr="0x00000000004019a0",at="<operator delete(void*)@plt>",thread-groups=["i1"]},{number="26.2",enabled="y",addr="0x00000000004025a9",func="operator delete(void*, void*)",file="/usr/include/c++/5/new",fullname="/usr/include/c++/5/new",line="135",thread-groups=["i1"]},{number="26.3",enabled="y",addr="0x00007ffff7adc6e0",at="<operator delete(void*)@plt>",thread-groups=["i1"]},{number="26.4",enabled="y",addr="0x00007ffff7ae0f10",at="<operator delete(void*)>",thread-groups=["i1"]},{number="26.5",enabled="y",addr="0x00007ffff7ae0f20",at="<operator delete(void*, unsigned long)>",thread-groups=["i1"]},{number="26.6",enabled="y",addr="0x00007ffff7ae0f30",at="<operator delete(void*, std::nothrow_t const&)>",thread-groups=["i1"]}
	(gdb)

	-break-insert -f "operator delete[]"
	^done,bkpt={number="27",type="breakpoint",disp="keep",enabled="y",addr="<MULTIPLE>",times="0",original-location="operator delete[]"},{number="27.1",enabled="y",addr="0x0000000000401a30",at="<operator delete[](void*)@plt>",thread-groups=["i1"]},{number="27.2",enabled="y",addr="0x00007ffff7ae0f40",at="<operator delete[](void*)>",thread-groups=["i1"]},{number="27.3",enabled="y",addr="0x00007ffff7ae0f50",at="<operator delete[](void*, unsigned long)>",thread-groups=["i1"]},{number="27.4",enabled="y",addr="0x00007ffff7ae0f60",at="<operator delete[](void*, std::nothrow_t const&)>",thread-groups=["i1"]}
	(gdb)



=== 2.2 Watch standard input/output


==== -var-create bn_io_stdin @ stdin->_IO_read_ptr

	^done,name="bn_io_stdin",numchild="1",value="0x0",type="char *",has_more="0"
	(gdb)

. On Unix: Create object variables watching changes in IO, using notation `bn_io_iofile`
. Future work: check if it works with GCC/MinGW for MsWin


==== -var-create bn_io_stdout @ stdout->_IO_write_ptr

	^done,name="bn_io_stdout",numchild="1",value="0x0",type="char *",has_more="0"
	(gdb)



==== -var-create bn_io_stderr @ stderr->_IO_write_ptr

	^done,name="bn_io_stderr",numchild="1",value="0x0",type="char *",has_more="0"
	(gdb)



==== -data-evaluate-expression bn_reopen_stdin()

	^done,value="{_flags = -72540024, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x0, _fileno = 0, _flags2 = 0, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 '\\000', _shortbuf = \"\", _lock = 0x7ffff7bb6790 <_IO_stdfile_0_lock>, _offset = -1, _codecvt = 0x0, _wide_data = 0x7ffff7bb49c0 <_IO_wide_data_0>, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = '\\000' <repeats 19 times>}"
	(gdb)

Only on MsWin: redirect stdin. Do the same for stdout and stderr: `-data-evaluate-expression bn_reopen_stdout()`, `-data-evaluate-expression bn_reopen_stderr()`



=== 2.3 Watch global variables


==== -var-create bn_gv_1 @ global_variable_name_1

. Get global variables from `PlayerSolution` (collected with ctags in building process in file `bn_tags.txt`).
. For each global variable, create a GDB-variable object with name `bn_gv_num`
. Create a DebuggerVariable object and load it from GDB response
. Add the DebuggerVariable to the VariableManager
. Animate variable creation in DataSegment and init it with the value obtained from GDB response
. If there is an overflow, simulate an DataSegment overflow. Do <<program-termination>>
. Future work: detect static local variables

The list of all variables for "all inclusive" example:

....
	-var-create bn_gv_1 @ all_arguments

	^done,name="bn_gv_1",numchild="1",value="{...}",type="std::vector<InputArgument*, std::allocator<InputArgument*> >",has_more="0"

	-var-create bn_gv_2 @ buffer
	^done,name="bn_gv_2",numchild="1",value="0x0",type="char **",has_more="0"
	(gdb)

	-var-create bn_gv_3 @ input_count
	^done,name="bn_gv_3",numchild="0",value="0",type="ull",has_more="0"
	(gdb)

	-var-create bn_gv_4 @ sorted_arguments
	^done,name="bn_gv_4",numchild="1",value="0x0",type="InputArgument **",has_more="0"
	(gdb)

	-var-create bn_gv_5 @ sorted_count
	^done,name="bn_gv_5",numchild="0",value="0",type="size_t",has_more="0"
	(gdb)

	-var-create bn_gv_6 @ global_program_name
	^done,name="bn_gv_6",numchild="2",value="{...}",type="InputArgument",has_more="0"
	(gdb)
....


Do <<variable-info>> to get data types and sizes:

. For vector `all_arguments`:

	-data-evaluate-expression sizeof(all_arguments)
	^done,value="24"
	(gdb)

	-interpreter-exec console "ptype /mt all_arguments"
	&"Python Exception <class 'gdb.error'> No type named InputArgument*.: \n"
	~"type = class std::vector<InputArgument*, std::allocator<InputArgument*> > [with _Tp = InputArgument *, _Alloc = std::allocator<InputArgument*>] : protected std::_Vector_base<InputArgument*, _Alloc> {\n"
	~"}\n"
	^done
	(gdb)

	-data-evaluate-expression &all_arguments
	^done,value="0x60b5c0 <all_arguments>"
	(gdb)

. For char** `buffer`:

	-data-evaluate-expression sizeof(buffer)
	^done,value="8"
	(gdb)

	-interpreter-exec console "ptype /mt buffer"
	~"type = char **\n"
	^done
	(gdb)

	-data-evaluate-expression &buffer
	^done,value="0x60b560 <buffer>"
	(gdb)

. For typdef `input_count`:

	-data-evaluate-expression sizeof(input_count)
	^done,value="8"
	(gdb)

	-interpreter-exec console "ptype /mt input_count"
	~"type = unsigned long long\n"
	^done
	(gdb)

	-data-evaluate-expression &input_count
	^done,value="0x60b568 <input_count>"
	(gdb)

. For InputArgument ** `sorted_arguments`:

	-data-evaluate-expression &sorted_arguments
	^done,value="0x60b570 <sorted_arguments>"
	(gdb)

	-data-evaluate-expression sizeof(sorted_arguments)
	^done,value="8"
	(gdb)

	-interpreter-exec console "ptype /mt sorted_arguments"
	~"type = class InputArgument : public AbstractArgument<char const*> {\n"
	~"  protected:\n"
	~"    std::__cxx11::string value2;\n"
	~"} **\n"
	^done
	(gdb)

. For size_t `sorted_count`:

	-data-evaluate-expression sizeof(sorted_count)
	^done,value="8"
	(gdb)

	-interpreter-exec console "ptype /mt sorted_count"
	~"type = unsigned long\n"
	^done
	(gdb)

	-data-evaluate-expression &sorted_count
	^done,value="0x60b5d8 <sorted_count>"
	(gdb)

. For object `global_program_name`:

	-data-evaluate-expression sizeof(global_program_name)
	^done,value="56"
	(gdb)

	-interpreter-exec console "ptype /mt global_program_name"
	~"type = class InputArgument : public AbstractArgument<char const*> {\n"
	~"  protected:\n"
	~"    std::__cxx11::string value2;\n"
	~"}\n"
	^done
	(gdb)

	-data-evaluate-expression &global_program_name
	^done,value="0x60b580 <global_program_name>"
	(gdb)



=== 2.4 Load standard input

. Read `bn_nn_input.txt` to a string
. Create characters for the test case's standard input
. Animate characters arriving through the tube until reaching the left edge
. Set cursor to position 0



=== 2.5 Finish starting phase

. Set visualization's state to `animating` (emit `animationStarted`)
. Do <<breakpoint-hit>> using the stored tree of *stopped response.
. Enter in execution loop. Do <<execution-loop>>



== 3. Execution threads



[[create-execution-thread]]
=== 3.1 Create execution thread

Each time `=thread-created,id="#"` is issued, create an `ExecutionThread` object. If there is an idle processor core, animate a robot appearing in the core with no line number. Ask gdb:

* `-thread-info`
* `-stack-info-depth`


==== -thread-info

For main thread:

	^done,threads=[{id="1",target-id="Thread 0x7ffff7fc9740 (LWP 4995)",name="alli",frame={level="0",addr="0x00000000004027c3",func="InputArgument::InputArgument",args=[{name="this",value="0x60b580 <global_program_name>"},{name="number",value="0"},{name="value",value="0x406dc6 \"all_inclusive\""}],file="alli.cpp",fullname="/tmp/alli/alli.cpp",line="64"},state="stopped",core="6"}],current-thread-id="1"
	(gdb)

. Locate the `ExecutionThread` with the given id, and make it to update its fields. (Be sure to store the `level` field).
. If there is a line number change, animate it on the robot, and highlight line in code segment (may require to load another file in code editor).
. If `executionThread.callStack.isEmpty()` and `thread-info/frame/file` is not in player solution: animate a function call with an empty frame, because it will not have a breakpoint-hit.


==== -stack-info-depth
All threads? or ` --thread 1`

	^done,depth="6"
	(gdb)

. Update the `ExecutionThread::callStackDepth` integer value (init value -1). If decreased animate a <<function-return>>.



=== 3.2 Remove execution thread


Each time `=thread-exited,id=#` is issued:

. Locate the ExecutionThread with given id and ask to remove.
. If thread has a cpu core assigned, remove thread from cpu core
. Remove thread from the scene, including its hidden or visible call stack
. Remove thread memory from CpuCores::executionThreads[] array



[[breakpoint-hit]]
== 4. Breakpoint hit

Player solution (inferior) stopped for hitting a breakpoint. Get the `/bkptno` integer value, and find the `DebuggerBreakpoint` object. If breakpoint object has one or more roles:

* If visualization is in `starting` state and `entryPointTree` is null Do <<program-entry-point>>
* If breakpoint is `functionBody` or `programEntryPoint`: Do <<function-call>>.
* If breakpoint is `userDefined`: Do <<user-defined-breakpoint>>.
* Do <<dynamic-memory-breakpoint>>



[[program-entry-point]]
==== 4.1 Program entry point:
	*stopped,reason="breakpoint-hit",disp="keep",bkptno="2",frame={addr="0x00000000004027c3",func="InputArgument::InputArgument",args=[{name="this",value="0x60b580 <global_program_name>"},{name="number",value="0"},{name="value",value="0x406dc6 \"all_inclusive\""}],file="alli.cpp",fullname="/tmp/alli/alli.cpp",line="64"},thread-id="1",stopped-threads="all",core="6"
	(gdb)

Visualization is in starting stage, not animating.
Inferior is stopped by a breakpoint hit.
This is the first breakpoint hit, threfore, it is the actual program entry point.
GDB always set the program entry point breakpoint to the main() function, but it may fail in C++ when there are global objects that call constructors before main().

. Because there are pending initialization steps, do not animate a function call.
. Store the GDB response tree for later use: `entryPointTree = response.tree`.
. Add the `pogramEntryPoint` role to `breakpoints[/bkptno]`.
. Continue as normal in <<set-dynamic-memory-breakpoints>>.



[[function-call]]
=== 4.2 Function call

Example at program's entry point:

	*stopped,reason="breakpoint-hit",disp="keep",bkptno="2",frame={addr="0x00000000004027c3",func="InputArgument::InputArgument",args=[{name="this",value="0x60b580 <global_program_name>"},{name="number",value="0"},{name="value",value="0x406dc6 \"all_inclusive\""}],file="alli.cpp",fullname="/tmp/alli/alli.cpp",line="64"},thread-id="1",stopped-threads="all",core="6"
	(gdb)


Player solution hit a breakpoint that has the role of `functionCall`. The breakpoint must be at the beginning of the body of a function in a file that is part of player solution.

. Get the `/thread-id="#"` from `*stopped` response, locate the `ExecutionThread` object.
. If `ExecutionThread` is active (has an assigned CPU core), animate the door opening in its CPU core.
. Build a memory frame for the new stack frame with the function name (`/frame/func`) in the roof. By default, memory frames are filled of garbage.
. Raise the memory roof to the CPU core opened door, to make the roof visible only. Arguments and variables will be made visible next.
. ToDo: If execution thread is idle in visualization (does not have an assigned CPU core), it should be stopped at inferior through GDB, to avoid it generating more responses.


==== -stack-info-depth

	^done,depth="2"
	(gdb)

. Update the ExecutionThread::callStackDepth integer value.


==== -stack-list-arguments 2 0 0

	^done,stack-args=[frame={level="0",args=[{name="this",type="InputArgument * const",value="0x60b580 <global_program_name>"},{name="number",type="ull",value="0"},{name="value",type="const char *",value="0x406dc6 \"all_inclusive\""}]}]
	(gdb)


The `0 0` argument is for selecting top frame only: `/frame/level == 0`

. Calculate the size required for all parameters, and the number required memory rows with garbage. Do <<variable-info>>
. Important: Ignore variables that begin with `__`. These variables are introduced by the programming language standard or compilers. E.g: `__PRETTY_FUNCTION__`.
. Raise the min(required memory rows, max allowed stack frame size/rowsize) rows and stop
. Create all variables in the memory rows, they may overflow.
. If there is overflow, animate a stack overflow. Do <<program-termination>>
. Create variables for arguments, not initialized yet. See below.
. Initialize each parameter with its argument, they will replace the garbage
. Create all remaining local variables. See below
. Hack: if a `char*` pointer has an address that is not in the `MemoryMapper`, and that address is lower than the first global variable, assume it is a literal string. Place the pointed string into variable's value limited to some extent. Indicate the value is in CodeSegment. Do the following to get the entire string:

	-data-evaluate-expression value
	^done,value="0x406dc6 \"all_inclusive\""
	(gdb)

. Raise the stack frame to make visible last variable
. Future: when user clicks over a variable, zoom it in (grey out everything else), and show all its details.


==== -stack-list-locals 2

	^done,locals=[{name="n",type="size_t",value="4196304"},{name="grid",type="char **",value="0x7fffffffdf50"},{name="error",type="int",value="0"}]
	(gdb)

Example for entry point (`InputArgument constructor`):

	^done,locals=[]
	(gdb)

Example for `main()`:

	^done,locals=[{name="__PRETTY_FUNCTION__",type="const char [22]"}]
	(gdb)

. Do the same than arguments, but some values may be unitialized (keep their garbage).
. Add the "memory frame legs" to the last memory row.
. Raise the memory frame until it is enterely visible (legs included).


==== -stack-list-variables 2

	^done,variables=[{name="argc",arg="1",type="int",value="2"},{name="argv",arg="1",type="char **",value="0x7fffffffdfb8"},{name="__PRETTY_FUNCTION__",type="const char [22]"}]
	(gdb)

This is an alternative to the previous two steps. It shows all the variables (parameters and local variables) at once. It may reduce a little of programming, if the animation of "parameter-passing" can be delayed.


[[variable-objects-to-pointed-data]]
==== Create variable-objects to pointed data

	-var-create bn_pd_1_1 @ *this
	^done,name="bn_pd_1_1",numchild="2",value="{...}",type="InputArgument",thread-id="1",has_more="0"
	(gdb)

Or?:

	-var-create bn_pd_1_1b @ this
	^done,name="bn_pd_1_1b",numchild="2",value="0x60b580 <global_program_name>",type="InputArgument * const",thread-id="1",has_more="0"
	(gdb)

Creates a variable object using notation `bn_pd_th_fc` where `pd` stands for 'pointed data', `th` the thread number, and `fc` the function call index in that thread. We create a variable object for each pointer we have in the stack:

	-var-create bn_pd_1_2 @ *value
	^done,name="bn_pd_1_2",numchild="0",value="97 'a'",type="const char",thread-id="1",has_more="0"
	(gdb)

	-var-create bn_pd_1_2b @ value
	^done,name="bn_pd_1_2b",numchild="1",value="0x406dc6 \"all_inclusive\"",type="const char *",thread-id="1",has_more="0"
	(gdb)

In both cases we need to keep track of the pointed data. If the pointed address matches a existing Variable object, point to it. If there is not a Variable object, make a child class object AnonymousVariable that trace value changes.

. ToDo: review Gede method to update (*this)
. Future: represent vtable in CodeSegment
. Future: test temporary values (e.g: anonymous objects returned by functions).
. Future: animate evaluation of expressions (reflecting operator precedence).


===== Alternative method for update pointed data

If GDB may reject to create many variables, an alternative is the following. Do not create variable-objects. When <<update-variables>> in execution loop, just traverse the list of local variables, and for those that are pointers, update the pointed data.

For each `Variable` that has the role of `pointer` [references are updated as normal variables] we need to update the pointed data, because the pointer may have been used to modify it:

	-data-evaluate-expression *this
	^done,value="{_vptr.AbstractArgument = 0x406f08 <vtable for AbstractArgument<char const*>+16>, number = 0, value1 = 0x406dc6 \"all_inclusive\"}"
	(gdb)




[[variable-info]]
=== 4.3 Get variable info

Does GDB/MI offer a method to get data-type size or unroll data types? As a workaround we use C/C++ expressions and normal user interface:

==== -data-evaluate-expression sizeof(this)

	^done,value="8"
	(gdb)

Get the size in bytes of a variable. It may not match the Botnu architecture (32 or 64bits).


==== -interpreter-exec console "ptype /mt this"

	~"type = class InputArgument : public AbstractArgument<char const*> {\n"
	~"  protected:\n"
	~"    std::__cxx11::string value2;\n"
	~"} * const\n"
	^done
	(gdb)

Get the unrolled data type of the variable. botNeumann must represent typedefs and compound structures with primitive C/C++ data types. This process is know as unroll the data type. GDB's user command `ptype` does this work, but it is not available in GDB/MI.

. Necessary only for data types that must be unrolled, e.g: typedefs. If data type can be recognized from any form of `-stack-list-variables` call, this step may be skipped.
. Map the data type to primitive data types
. Use structs to represent classes and structures
. Future: Use structs to represent the maximum-sized element of unions
. ToDo: Use variable objects to unroll structures


==== -data-evaluate-expression &this

	-data-evaluate-expression &this
	^done,value="0x7fffffffde38"
	(gdb)

. Get the inferior address for the variable.
. Assign an address in the visualization in some MemoryFrame/MemoryRow
. Add the to the MemoryMapper the GDB address, the visualization address, and a pointer to the Variable object.



Example with primitive type:

	-data-evaluate-expression sizeof(number)
	^done,value="8"
	(gdb)

	-interpreter-exec console "ptype /mt number"
	~"type = unsigned long long\n"
	^done
	(gdb)


Example with pointer to primitive:

	-data-evaluate-expression sizeof(value)
	^done,value="8"
	(gdb)

	-interpreter-exec console "ptype /mt value"
	~"type = const char *\n"
	^done
	(gdb)



[[user-defined-breakpoint]]
=== 4.4 User defined breakpoint

. Change visualization state to `paused`.
. Set VisualizationSpeed::seeking to false
. When debugger enters in idle state, no more `exec-next` commands will be automatically sent.
. Execution will continue when user presses the resume button or the step button.



[[dynamic-memory-breakpoint]]
=== 4.5 Dynamic memory management breakpoint

The execution stopped at a breakpoint set to a dynamic memory management function. The call may be done for the player solution directly or indirectly for any library function called by player. Eg:

	char* buffer = (char*) malloc(1024); // explicit call to malloc
	Fraction* fractions = new Fraction[10]; // explicit call to new[]
	printf("Average = %lf", average); // implicit call to malloc

Explicit calls are always reflected in the animation. Implicit calls sometimes may be reflected in the visualization. The way we determine the function call should or not be animated, is storing information about the call, and use this information later to know if some user variables or pointed data were modified (e.g: a GDB variable-object changed).

These breakpoints are fired after issuing a `next-step` command in execution loop. For example:

[source,js]
----
	-exec-next
	^running
	*running,thread-id="all"
	(gdb)

	=breakpoint-modified,bkpt={number="20",type="breakpoint",disp="keep",enabled="y",addr="0x00007ffff72dc580",func="__GI___libc_malloc",file="malloc.c",fullname="/build/glibc-Qz8a69/glibc-2.23/malloc/malloc.c",line="2900",thread-groups=["i1"],times="1",original-location="__libc_malloc"}

	~"\n"
	~"Breakpoint 20, __GI___libc_malloc (bytes=59) at malloc.c:2900\n"
	&"2900\tmalloc.c: No such file or directory.\n"

	*stopped,reason="breakpoint-hit",disp="keep",bkptno="20",frame={addr="0x00007ffff72dc580",func="__GI___libc_malloc",args=[{name="bytes",value="59"}],file="malloc.c",fullname="/build/glibc-Qz8a69/glibc-2.23/malloc/malloc.c",line="2900"},thread-id="1",stopped-threads="all",core="0"
	(gdb)
----

. Create an object with the following information

[source,c++]
----
	class DynamicMemoryBlock
	{
		enum functionCalled; // malloc/calloc/realloc/free/new/new[]/delete/delete[]
		size_t size; // from value of /frame/args/bytes
		void* address; // from return value
		int thread; // from value of /thread-id
		bool directCall; // Directly called by player solution code
	}
----

. Extract the size and thread from the `*stopped,reason="breakpoint-hit"` response:

	dynamicMemoryBlock.size = /frame/args/1/value;
	dynamicMemoryBlock.thread = /thread-id;

. The role of the breakpoint `breakpoints[/bkptno]->hasRole(x)` tell us the type of function called:

	* `mallocCalled`: Process memory allocation (uninitialized)
	* `callocCalled`: Process memory allocation (initialized)
	* `reallocCalled`: Process memory reallocation
	* `freeCalled`: Process memory deallocation

	* `newValue`: C++ new operator
	* `newArray`: C++ new[] operator
	* `deleteValue`: C++ delete operator
	* `deleteArray`: C++ delete[] operator

. Store the object in `HeapSegment::dynamicMemoryBlocks[]`


==== -exec-finish

[source,js]
----
	^running
	*running,thread-id="all"
	(gdb)

	*stopped,reason="function-finished",frame={addr="0x00007ffff7ae2e78",func="operator new(unsigned long)",args=[],from="/usr/lib/x86_64-linux-gnu/libstdc++.so.6"},gdb-result-var="$1",return-value="(void *) 0x61dc20",thread-id="1",stopped-threads="all",core="1"
	(gdb)
----

We are not interested in debugging the body of the library's memory function. We force the function to return. From /return-value"(void *) addr" we get the return address.

	dynamicMemoryBlock.address = extractAddress(/return-value);


==== -stack-info-depth

	^done,depth="4"
	(gdb)


==== -stack-list-frames

[source,js]
----
	^done,stack=[frame={level="0",addr="0x00007ffff7ae2e78",func="operator new(unsigned long)",from="/usr/lib/x86_64-linux-gnu/libstdc++.so.6"},frame={level="1",addr="0x00007ffff7b76aed",func="void std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_construct<char const*>(char const*, char const*, std::forward_iterator_tag)",from="/usr/lib/x86_64-linux-gnu/libstdc++.so.6"},frame={level="2",addr="0x00007ffff7b76c4c",func="std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(char const*, std::allocator<char> const&)",from="/usr/lib/x86_64-linux-gnu/libstdc++.so.6"},frame={level="3",addr="0x00000000004021d6",func="main",file="alli.cpp",fullname="/tmp/alli/alli.cpp",line="164"}]
	(gdb)
----

Study the stack. The `level=0` contains the function that called the memory management function. It may be:

. A function defined by player, i.e. `/stack/1/from` is in player solution: Make `dynamicMemoryBlock.directCall = true`.

. A C++ dynamic memory operator: update `dynamicMemoryBlock.functionCalled = parse(/stack/1/func)`. The previous step must be repeated with the next function in stack `/stack/2`.

. A library function: Do nothing.

If `dynamicMemoryBlock.directCall` is true, the player directly called the memory management function, do a <<dynamic-memory-animation>>, even though no variables have been modified. For example, user may ask to allocate dynamic memory, but he/she did not stored the returned address (i.e. a memory leak should be visualized).

. Otherwise, animation is skipped and the DynamicMemoryBlock object is stored until it gets freed by a breakpoint hit at `free*()`.



[[dynamic-memory-animation]]
==== Dynamic memory animation

If an animation must be done:

. Pass the DynamicMemoryBlock to the HeapSegment object
. If block was allocated:

	- Look for the first empty space larger or equal than block.size
	- Get the pointed data type (from gdb info?)
	- Animate allocation of size/sizeof(data_type) values
	- If values were allocated with malloc, keep garbage, otherwise, try to init using gdb values
	- If there is not enough space, animate segmentation fault (see Program termination)

If block was deallocated:

	- Look for the corresponding memory allocation block, if not found, animate segmentation fault
	- If the operator for deallocating matches the operator used for allocation (xalloc-free,
	  new-delete, new[]-delete[]), remove `dynamicMemoryBlock.size` bytes from heap and remove the block from the `MemoryMapper`.
	- (Else) Animate removal of one object (ToDo: study removing delete[] to single object)

If block was reallocated (i.e. using realloc)

	- If the address is nullptr, nothing was re-allocated, and ignore the event
	- If the address is the same and size is 0, act as a call to free() [?]
	- If the address is the same and size is smaller than the previous, shrink data
	- If the address is not null and size is larger than the previous, look for enough free space
	  in HeapSegment. Act as a normal allocation (malloc, not calloc). If not segmentation fault,
	  finally act as deallocation (free) of the previous address.


==== Returning to execution loop

We need to go back to the player's code where the execution thread was running.
Notice: I had no luck with `step` (even in not debugging code) or `until` commands.
As a workaround, we ask for the number of functions running on the call stack of the execution thread (in previous example, currentLevel=4).
We know the level of the returning point in ExecutionThread::callStack.level (returnToLevel) (for this example, 1).
Simply ask `-exec-finish` to GDB `currentLevel - returnToLevel` times, until the returnToLevel has been reached, and ignore their intermediate results.

	-exec-finish
	-stack-info-depth

When finally arrived to the player's function before the dynamic memory function was stopped by breakpoint. We return to the execution loop at <<update-variables>> where pointers will be updated.



==== C++ dynamic memory operators

Because C++ dynamic memory operators (new, new[], delete, delete[]) call the libc counterparts (malloc and free), if we set breakpoints for all of them, we will have double breakpoint-hits each time a C++ operator is called. We may react in several ways.

First way is to set both types of breakpoints (C functions and C++ operators). We know that C++ operator breakpoint will be hit first. At this point, we create the `DynamicMemoryBlock` object. When the C function breakpoint is hit, we update the `DynamicMemoryBlock` as usual, but keeping its value `functionCalled` intact.

Second way is to set breakpoints only to C functions. After getting the parameters, we have to go back to the user code, finishing functions. Therefore, we have to traverse the stack. The function call that is one step before the C memory management function, should be the C++ operator. At that time, we can update the `functionCalled` field of the `DynamicMemoryBlock`. If we continue traversing the stack, we can know if the next function call is located in player solution code or a library.




[[execution-loop]]
== 5. Execution loop


Each step of this loop is considered a step of the visualization. When visualization is paused and player presses the `Step` button, one *visualization step* is done (animated). When visualization is in seeking state, a visualization step is issued each time there is no pending commands to be sent to GDB.

A visualization step moves around the `-exec-next` instruction. Each time this command is sent, some events may happen: a variable is changed, a function is called, a function is returned... The breakpoint system will catch the function calls and dynamic memory changes. In each visualization step we have to update the remaining elements: execution threads (line number), stack, data segment, and standard input/output.


=== 5.1 Execute next line

==== -exec-next

	^running
	*running,thread-id="all"
	(gdb)
	*stopped,reason="end-stepping-range",frame={addr="0x00000000004027d2",func="InputArgument::InputArgument",args=[{name="this",value="0x60b580 <global_program_name>"},{name="number",value="0"},{name="value",value="0x406dc6 \"all_inclusive\""}],file="alli.cpp",fullname="/tmp/alli/alli.cpp",line="66"},thread-id="1",stopped-threads="all",core="6"
	(gdb)

The _visualization step_ finished executing the next instruction.

. Update ExecutionThread `/thread-id` with line number `/frame/line`.
. If response is `*stopped,reason="breakpoint-hit"` a breakpoint was hit. A function was called or dynamic memory was modified. The <<breakpoint-hit>> section will react accordingly.
. If a function was called, after animating the new stack frame appearing, continue in <<update-variables>>. Otherwise continue as normal.



[[stay-in-function]]
=== 5.2 Stay in function

If response was `*stopped,reason="end-stepping-range"`, one line of current function was executed, and no a new function was called. Update potential changes in local variables of the current function:


==== -stack-info-depth

	^done,depth="6"
	(gdb)

Check if we are running on the same function

. If `/depth` is one less than `ExecutionThread::callStackDepth` integer value (init value -1), animate a function return. Do: <<function-return>>.
. After function return animation, update `ExecutionThread::callStackDepth = /depth`
. Future: study callback functions: eg: `qsort()`


==== -stack-list-variables 2

	^done,variables=[{name="this",arg="1",type="InputArgument * const",value="0x60b580 <global_program_name>"},{name="number",arg="1",type="ull",value="0"},{name="value",arg="1",type="const char *",value="0x406dc6 \"all_inclusive\""}]
	(gdb)

Update local variables:

. ToDo: This command is unnecesary if a player solution function was called, because the stack frame has changed. If we try to update the local variables, it will be done in the new function call instead of the caller. This is a problem, because complex calls such as `int x = 3, y = func(++x), z = x + y` will miss the update of variables in the caller before `func()` is called.
. Get the value of all the local variables, and pass them to the CallStack or VariableManager
. If some variables have changed their values, animate them
. ToDo: If we create variable-objects for each local variable in all threads, this comparison
  step may be not necessary, but GDB may reject to update many of them.
. ToDo: GDB consider local static variables as normal local variables. We have to separe them



[[update-variables]]
=== 5.3 Update variables


==== -var-update --all-values *

	^done,changelist=[]
	(gdb)

Update all defined GDB variable-objects. We can infer from the variable-object name, the type of modified variable:

	bn_io_file  :  standard input/output/error streams
	bn_gv_n     :  global variable with number n
	bn_pd_th_fc :  pointed data in function call fc of thread th

. If the list of changed variables is empty, we are done
. If standard input/output stream changed, Do <<update-input-output>>
. A global variable or pointer changed its value, do as follows

. If variable is not a pointer or reference, animate the variable changing to the new value. For example, the pod containing the value may increase a decrease its size while the value fades.
. If variable is a reference, only the pointed data can change. We have to find the referred data using the `MemoryMapper`. If there is a variable with the referred address, animate a value change. References may be represented as pointers using a 75% opacity or a different border.
. If variable is a pointer, both the pointer and the pointed data may change. Check for a pointed data change in the same way references do. Check for a change in the address. Look for the new address in the `MemoryMapper`.
. If the referred variable is in dynamic memory and it does not have a Variable assigned, create it in dynamic memory, and animate the change. Do <<dynamic-memory-animation>>

. ToDo: How to detect rvalues in GDB? Currently botNeumann is unable to draw references or pointers to temporary objects in stack. These temporaries may be also represented as values hold by the robot.


[[update-input-output]]
=== 5.4 Update input/output

A variable object indicated there was a change in input/output streams.

==== -data-evaluate-expression bn_tell_stdin()

	^done,value="0"
	(gdb)

. Capture the number of bytes moved. If value is 0, do nothing.
. Animate Robot consuming `value` chars from stdin (robot turns)
. ToDo: Locate what variable received the read input (it should be included in -var-update result)
. Animate robot converting to the data type of the changed variable
. If no target variable is found, animate robot discarding the read bytes


==== -data-evaluate-expression bn_tell_stdout()
	^done,value="0"
	(gdb)

. Capture the number of bytes moved. If value is 0, do nothing.
. For stdout it is so difficult to determine which variables were involved to produce the
  output. Animate the robot building the output message and sending it by the stdout.
. Check if output matches expected output and turn on/off the output tester accordingly.


==== -data-evaluate-expression bn_tell_stderr()
	^done,value="0"
	(gdb)

. Capture the number of bytes moved. If value is 0, do nothing.
. ToDo: For stderr ignore the event, for now
. ToDo: provide more tubes for user own files (FILE*, std::istream, std::fstream...)



[[function-return]]
=== 5.5 Function return

. Animate stack frame being dropped through the CPU core's memory interface
. Remove local variables from VariableMapper
. If using pointed data variable objects `bn_pd_th_fc`, remove all of the for function call `fc` index running by execution thread `th`. Example:

	-var-delete bn_pd_1_2
	^done,ndeleted="1"
	(gdb)

. If there are remaining function calls, make them to move a step towards the robot. Return to the <<execution-loop>>
. If there are no remaining function calls, execute `-exec-continue`:


==== -exec-continue

An execution thread may end with no stack frames (function calls). This is possible because we are not animating all function calls. Library functions may be executing. For example GNU libc++ runs `__static_initialization_and_destruction_0` to call global objects' constructors before main().


[source,js]
----
	^running
	*running,thread-id="all"
	(gdb)

	=breakpoint-modified,bkpt={number="18",type="breakpoint",disp="keep",enabled="y",addr="0x000000000040219e",func="main(int, char**)",file="alli.cpp",fullname="/tmp/alli/alli.cpp",line="162",thread-groups=["i1"],times="1",original-location="alli.cpp:162"}

	=breakpoint-modified,bkpt={number="19",type="breakpoint",disp="del",enabled="y",addr="0x000000000040219e",func="main(int, char**)",file="alli.cpp",fullname="/tmp/alli/alli.cpp",line="163",thread-groups=["i1"],times="1",original-location="main"}

	~"\n"
	~"Breakpoint 18, main (argc=2, argv=0x7fffffffdfb8) at alli.cpp:163\n"
	~"163\t{\n"

	*stopped,reason="breakpoint-hit",disp="keep",bkptno="18",frame={addr="0x000000000040219e",func="main",args=[{name="argc",value="2"},{name="argv",value="0x7fffffffdfb8"}],file="alli.cpp",fullname="/tmp/alli/alli.cpp",line="163"},thread-id="1",stopped-threads="all",core="2"

	=breakpoint-deleted,id="19"
	(gdb)
----

We process the responses as usual, in the same way it happens in `starting` state.

. `*running`: Set GDB state to running again.
. `=breakpoint-modified`: Update the modifief breakpoint.
. `*stopped,reason="breakpoint-hit"`: Do <<breakpoint-hit>>.
. `=breakpoint-deleted,id="19"`: Remove the breakpoint from `breakpoints[]` array, and make its pointer null. In this example this breakpoint was set by GDB as program entry point and it has the `programEntryPoint` role.
. Finally, return to the <<execution-loop>>.


Future: We could represent these library functions as empty stack frames, or just one stack frame (using 1 memory row) having by title _library functions_. In order to show the actual function calls, we list all frames in stack:

==== -stack-list-frames

	^done,stack=[frame={level="0",addr="0x00007ffff7874580",func="__GI___libc_malloc",file="malloc.c",fullname="/build/glibc-Qz8a69/glibc-2.23/malloc/malloc.c",line="2900"},frame={level="1",addr="0x00007ffff785e1d5",func="__GI__IO_file_doallocate",file="filedoalloc.c",fullname="/build/glibc-Qz8a69/glibc-2.23/libio/filedoalloc.c",line="127"},frame={level="2",addr="0x00007ffff786c594",func="__GI__IO_doallocbuf",file="genops.c",fullname="/build/glibc-Qz8a69/glibc-2.23/libio/genops.c",line="398"},frame={level="3",addr="0x00007ffff786b69c",func="_IO_new_file_underflow",file="fileops.c",fullname="/build/glibc-Qz8a69/glibc-2.23/libio/fileops.c",line="556"},frame={level="4",addr="0x00007ffff786c60e",func="__GI__IO_default_uflow",file="genops.c",fullname="/build/glibc-Qz8a69/glibc-2.23/libio/genops.c",line="413"},frame={level="5",addr="0x00007ffff784d260",func="_IO_vfscanf_internal",file="vfscanf.c",fullname="/build/glibc-Qz8a69/glibc-2.23/stdio-common/vfscanf.c",line="634"},frame={level="6",addr="0x00007ffff785c5df",func="__isoc99_scanf",file="isoc99_scanf.c",fullname="/build/glibc-Qz8a69/glibc-2.23/stdio-common/isoc99_scanf.c",line="37"},frame={level="7",addr="0x00000000004008fb",func="main",file="solution.c",fullname="/tmp/tictactoe_nxn/solution.c",line="15"}]
	(gdb)




[[program-termination]]
== 6. Program termination (visualization stop)

Program may terminate for these reasons:

. Player stopped visualization
. Program finished normally
. Program received a signal from OS (eg: segmentation fault)
. Program failed to run in the virtualized environment (unit) (eg: stack overflow)



If player stopped visualization or program failed to run in the constrained environmentof the unit, stop inferior execution:

==== -exec-interrupt

	^done
	(gdb)


. Stop gdb also?:

==== -gdb-exit

	^exit
	=thread-exited,id="1",group-id="i1"
	=thread-group-exited,id="i1"


If inferior was finished normally or by a signal, GDB will stop it and emit a *stopped async record. The reasons may be:

* exited: The inferior exited.
* exited-normally: The inferior exited normally.
* signal-received: A signal was received by the inferior.

Provide some feedback to user. Stop the visualization and move to state inferior-exited, where only Stop button is enable. When user presses it, visualization returns to editing state.



[[segmentation-fault]]
=== 6.1 Segmentation fault

A segmentation fault is simulated when the player solution requires more memory than the available in the Unit. The inferior is likely to have enough memory to continue running normally.

. Animate robots vibrating and then falling (turning)
. Provide user feedback (a dialog) pointing the overflowed segmentation
. Give advice to reduce the amount of memory required by his/her solution
. Enter visualization in `finished` state, only the Stop button is available
. When user presses the Stop button, return to the `editing` state


== A. Miscellaneous commands (reference)


==== -exec-until solution.c:15

	^running
	*running,thread-id="all"
	(gdb)
	*stopped,reason="location-reached",frame={addr="0x00007ffff786b69c",func="_IO_new_file_underflow",args=[{name="fp",value="0x7ffff7bb48e0 <_IO_2_1_stdin_>"}],file="fileops.c",fullname="/build/glibc-Qz8a69/glibc-2.23/libio/fileops.c",line="556"},thread-id="1",stopped-threads="all",core="2"
	(gdb)
