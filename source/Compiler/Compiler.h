#ifndef COMPILER_H
#define COMPILER_H

#include <QObject>
#include <QFileInfoList>

class Diagnostic;
class QProcess;

/**
	@brief Frontent to the command line compiler

	This object is in charge of compiling the solution generated by the player, that is,
	the source code files, and generate the executable. This object collects diagnostics (warnings
	and errors). The compilation is made by a system call in desktop operating systems. In
	mobile devices, the compilation is sent to a TCP server.

	All files are always compiled with all warnings enabled (-Wall), C++11 enabled (-std=c++11),
	debug information enabled (-g). Each source file is compiled by separate, generating a .o
	file. If there is an updated .o, the file is ommited in order to make the process faster.
 */
class Compiler : public QObject
{
	Q_OBJECT

  private:
	/// List of warnings and errors generated when compiling a piece of code
	QList<Diagnostic*> diagnostics;
	/// Indicates the number of error collected during the compilation process. If value is 0
	/// the solution can be run, even it would have warnings. This value is valid only
	/// after a compilation process has finished.
	int errorCount;
	/// Path of the target executable file. It will be linked only if it is out-dated
	QFileInfo executablePath;

  public:
	/// Constructor
	explicit Compiler(QObject *parent = nullptr);
	/// Destructor
	~Compiler();
	/// Get access to the list of diagnostics (warnings and errors)
	inline const QList<Diagnostic*>& getDiagnostics() const { return diagnostics; }
	/// Indicates the number of error collected during the compilation process. If value is 0
	/// the solution can be run, even it would have warnings. This value is valid only
	/// after a compilation process has finished. If called before, it will return -1
	inline int getErrorCount() const { return errorCount; }
	/// Get the name of the default C++ compiler for this platform
	static QString getCxxCompiler();
	/// Default parameters: all warnings enabled (-Wall), C++11 enabled (-std=c++11),
	/// debug information enabled (-g), and so on
	static QStringList getDefaultCompilerArguments();
	/// Default linker arguments
	static QStringList getDefaultLinkerArguments();
	/// Given a source file, returns its .o object file
	static QFileInfo getObjectFileFor(const QFileInfo& sourceFilePath);

  signals:
	/// Emitted when a compilation process has finished
	void finished();

  public slots:
	/// Compiles the given source file. It starts a separate thread. When it finishes, the
	/// @a compilationFinished() signal is emitted. The result and products of the compilation
	/// (diagnostics, intermediate representation) can be get using accesor methods
//	bool compile(const QString& filename, const QFileInfo& executablePath);
	/// Compiles the given set of source files
	/// @see compile(const QString&)
	void compile(const QFileInfoList& filepaths, const QFileInfo& executablePath);
	/// Erases all information about a compiling. This method is automatically called by compile()
	void clear();

  protected:
	/// Compiles the given .cpp file and generates its respective .o in the same folder
	/// @param newerThanExecutable if a boolean value is given, sets it to true if the generated
	/// .o is newer than the executable, and therefore, the executable is out-dated and should be
	/// linked again
	/// @return the file path of the generated .o file. If there already is an updated .o, the
	/// source files is not compiled again, to avoid wasting of resources
	QFileInfo generateObjectFile(const QFileInfo& sourceFilePath, bool *newerThanExecutable = nullptr);
	/// Call the compilers to generate the executable or update it
	/// @param The complete list of object files that will compound the executable
	void linkExecutable(const QStringList& objectFiles);
};

#endif // COMPILER_H
