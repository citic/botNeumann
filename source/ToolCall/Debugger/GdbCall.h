#ifndef GDBCALL_H
#define GDBCALL_H

#include "GdbCommon.h"
#include "GdbResponse.h"
#include "GdbToken.h"
#include "DebuggerCall.h"

#include <QByteArray>
#include <QList>

class QSocketNotifier;
class GdbTreeNode;
class GdbItemTree;

class GdbCommand
{
  protected:
	static size_t instances;
	size_t number;
	QString text;

  public:
	explicit GdbCommand(const QString& text) : number(++instances), text(/*number + */text) { }
	inline size_t getNumber() const { return number; }
	inline const QString& getText() const { return text; }
	inline QString getCommand() const { return text + '\n'; }
};

class GdbCall : public DebuggerCall
{
	Q_OBJECT

  public:
	/// The state of GDB being controlled by this object
	enum State
	{
		STATE_STOPPED,
		STATE_RUNNING,
		STATE_FINISHED
	};

  protected:
	/// The state of GDB being controlled by this object
	State state = STATE_STOPPED;
	/// Identifier of the pseudoterminal where user program will be run
	/// This id is known as Device File Descriptor un Unix jargon
	/// This pseudoterminal will be given to gdb to control inferior
	int inferiorPseudoterminalId = 0;
	/// A QSocketNotifier is used to monitor activity on a file descriptor, i.e.
	/// It will emmit signals when GDB produces output
	QSocketNotifier* pseudoterminalActivityMonitor = nullptr;
	/// Controls the number of gdb commands being run
	int busy = 0;
	/// The list of commands sent to GDB that are waiting for GDB response (output)
	QList<GdbCommand> pendingCommands;
	/// Raw output received from GDB process
	QByteArray gdbRawOutput;
	/// A list of keywords, variables, texts... that result of parsing GDB output
	QList<GdbToken*> pendingTokens;
	/// A list of tokens that were previously in pendingTokens and were processed
	QList<GdbToken*> processedTokens;
	/// A list of GDB responses that were assambled from the parsed tokens
	QList<GdbResponse*> responseQueue;

  public:
	/// Constructor
	explicit GdbCall(QObject *parent = nullptr);
	/// Destructor
	virtual ~GdbCall();
	/// Gets the state of the gbd instance being controlled by this object
	inline State getState() const { return state; }
	/// Stats the execution of gdb and inferior
	bool start();
	/// Gets the inferior pseudoterminal name, something like /dev/pts/nn where
	/// nn is a number that identifies the pseudoterminal
	const char* getInferiorPseudoterminalName() const;
	/// Sends a command to GDB, for example "-file-exec-and-symbols"
	/// @param command The GDB Machine Interface command
	/// @param resultData A Pointer to an existing tree where items generated by GDB
	/// will be stored, for example, to get the list of function calls on stack
	/// @return The enumeration value of the last GdbResult record: done, running, error...
	GdbResult sendGdbCommand(const QString& command, GdbItemTree* resultData = nullptr);

  protected:
	/// Creates a pseudoterminal where user program (inferior) is going to run
	/// This pseudoterminal will be given to gdb to control inferior
	bool createPseudoterminal();
	/// Sets signals and slots to detect when GDB produces output
	void startMonitoringPseudoterminal();
	/// Reads a response from Gdb. It will wait if Gdb has still no responses
	GdbResult readFromGdb(GdbItemTree* resultData, bool waitUntilGdbHasOutput = true);
	/// If there is output generated by GDB, parses it and generate a list of tokens
	GdbResponse* parseGdbOutput();
	/// Process any standard error message generated by GDB
	void dumpGdbStandardError();
	/// Returns true if there is a token ready to be processed, false otherwise
	inline bool isTokenPending() { return peekToken() != nullptr; }
	/// Deletes all processed token objects from memory, if any
	void deleteProcessedTokens();
	/// Gets a pointer to the next token that is ready to be processed, nullptr if none
	GdbToken* peekToken();
	/// Moves the first pending token (in pendingTokens list) to processedTokens list
	/// @returns A pointer to the token moved, nullptr if there is no pending tokens
	GdbToken* popToken();
	/// @brief Checks and pops a token if the kind is as expected.
	/// @return The found token or nullptr if no hit.
	GdbToken* checkAndPopToken(GdbToken::Type tokenType);
	/// Waits until there is a token
	GdbToken* eatToken(GdbToken::Type tokenType);
	/// Reads any standard output generated by GDB, slices it into lines, and parsers
	/// each line to generate tokens (lexical parsing)
	void readTokens();
	/// Parsers a line generated by GDB in standard output, and generate several tokens
	/// that will be stored into @a pendingTokens list
	void parseGdbOutputLine(const QString& line);
	/// Lines such as '=thread-group-added,id="i1"'
	GdbResponse* parseAsyncRecord(GdbToken::Type tokenType, GdbResponse::Type outputType);
	/// Lines such as '~"Any long text description"'
	GdbResponse* parseStreamRecord();
	/// Lines such as ''
	GdbResponse* parseResultRecord();
	/// Parses items in the form item=value,item=[value1,value2],item={item1,item2}
	/// @return 0 on success, -1 on error
	int parseItem(GdbTreeNode* parent);
	/// Parses the value of an item
	int parseValue(GdbTreeNode* item);
	/// Alert the listener, if any, each response generated by GDB
	void dispatchResponses();

  signals:
	/// Emitted when there is a message from GdbCall that is useful to display into a log widget
	void onGdbLogMessage(GdbLogType type, const QString& message);
	/// Emmited when a response was fetched from gdb
	void onGdbResponse(const GdbResponse* response);

  public slots:
	/// Called when GDB process has generated output
	void onReadyReadStandardOutput();

  private slots:
	/// Called each time GDB produces output
	void onGdbOutput(int fileDescriptor);
};

#endif // GDBCALL_H
