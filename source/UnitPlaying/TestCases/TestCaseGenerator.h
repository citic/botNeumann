#ifndef TESTCASEGENERATOR_H
#define TESTCASEGENERATOR_H

#include "CompiledProgram.h"

class PlayerSolution;
class Unit;

/**
Units can have test cases generators. They are pieces of C/C++ source code that are able to produce
an arbirary number of test cases. Test case generators are compiled and the executable is called
during just before the visualization process in order to generate test cases to visualize.

There are two types of test case generators:

 - Standard Test Case Generators. They write the test case text to the standard output. A Unit's
   solution is required in order to generate the expected test case's output/error.

 - File Test Case Generators. They receive all the files to be generated by argument, and they
   create all the four files for the test case.

This class manages both types of generators.
@see Botnu.dtd comments for more details.
*/
class TestCaseGenerator : public CompiledProgram
{
	Q_OBJECT
	Q_DISABLE_COPY(TestCaseGenerator)

  protected:
	/// This is a helper class for PlayerSolution
	PlayerSolution* playerSolution = nullptr;
	/// And requires the Unit
	Unit* unit = nullptr;
	/// The number of the test case to start with. Required to name the test cases: bn_04_input.txt
	int currentTestCaseIndex = -1;
	/// True when the generator has been built
	bool generatorBuilt = false;
	/// True when this is a standard generator and a solution has been built
	bool solutionBuilt = false;
	/// Used to compiler a solution
	CompiledProgram* solution = nullptr;

  protected:
	/// Test case number argument
	QString number;
	/// Total number of cases
	QString total;
	/// Test case arguments file path
	QString args;
	/// Test case input file path
	QString input;
	/// Test case expected output file path
	QString output_ex;
	/// Test case expected error output file path
	QString error_ex;

  public:
	/// Constructor
	explicit TestCaseGenerator(PlayerSolution* playerSolution, Unit* unit, QObject* parent = nullptr);
	/// Starts the generation process according to the type of this generator. This requires
	/// to build (compile and link) the generator's executable, and run it. The amount of test
	/// cases to be generated are gotten from generator->defaultRuns
	/// Emits generatorFinished when done
	bool generate(const ProgramText* generator, int currentTestCaseIndex);
	/// Returns the number of generated test cases after the generate process has finished
	inline int getLastGeneratedTestCaseIndex() const { return currentTestCaseIndex; }

  signals:
	/// Emitted when the generation of test cases finishes
	void generationFinished();

  protected slots:
	/// Called after the build process of the test case generator has finished.
	/// If there were not errors, the generation of test cases start
	bool generatorBuildFinished();
	/// Called after the build process of the solution has finished. This method is only called
	/// when @a programText is a standard generator
	bool solutionBuildFinished();

  protected:
	/// Starts the build process of a random selected solution
	bool buildASolution();
	/// Calls the standard generator to fill the current test case and the solution to generate
	/// the expected outputs. Return true on success
	bool callStandarGenerator();
	/// Calls the file generator to fill the current test case
	bool callFileGenerator();
	/// Called when the build process of generators and solutions is finished
	bool generateTestCases();
};

#endif // TESTCASEGENERATOR_H
