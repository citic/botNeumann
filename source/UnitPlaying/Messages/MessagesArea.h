#ifndef MESSAGESAREA_H
#define MESSAGESAREA_H

#include "GdbCommon.h"
#include "VisualizationContext.h"

#include <QDockWidget>

class Compiler;
class CompiledProgram;
class Diagnostic;
class ExecutionThread;
class GdbItemTree;
class PlayerSolution;
class StandardInputOutputInspector;

class QListWidget;
class QTabWidget;
class QTextEdit;

/**
	@brief Manages the controls to display textual input/output to the player. For example

	- UnitDescription: Description of the problem that player should solve in the active unit
	- ToolsOutput: Warnings, errors, and other output generated by compilers, linkers, debuggers
	- PlayerSolutionInOut: Standard input sent and standard output generated by player's solution
 */
class MessagesArea : public QDockWidget
{
	Q_OBJECT
	Q_DISABLE_COPY(MessagesArea)

  protected:
	/// Manages the tabs for output generated by build and debug tools
	QTabWidget* messagesTabWidget;
	/// Displays the current unit description
	QTextEdit* unitDescription;
	/// A control to display compiler, linker and debugger output
	QListWidget* toolsOutput;
	/// Compiler object that generated the diagnostics shown in the tools output list
	Compiler* compiler;
	/// Let user compare differences between test case's input/output/error and his/her solution
	StandardInputOutputInspector* standardInputOutputInspector = nullptr;

  public:
	/// Constructor
	explicit MessagesArea(QWidget* parent = nullptr, Qt::WindowFlags flags = 0);
	/// Destructor
	~MessagesArea();
	/// Display the given text in the unit description area, and makes it active if the second
	/// parameter is true
	void setUnitDescription(const QString& description, bool makeActiveTab);
	/// Loads the expected input/output/error in the StandardInputOutputInspector from the test
	/// case files, and set the cursors to the first character of them
	bool loadTestCase(int testCaseNumber, PlayerSolution* playerSolution);

  signals:
	/// Emitted when user selects one of the diagnostics in the tools output
	/// @param index The index of the selected diagnostic in the allDiagnostics list
	void diagnosticSelected(int index);

  public slots:
	/// Called when a new compiling process has started, in order to clear old results
	void clear();
	/// Called when a build process (compiling and linking) has finished, and ther are results
	/// The compiler pointer is required in order to get the diagnostics. If there are errors
	/// and the messages dock widget is hidden, it is made visible and the tools output tab is
	/// made active. If there are not errors, the tools output tab is just cleared.
	void playerSolutionBuilt(CompiledProgram* compiledProgram);
	/// Appends a message sent by the debugger (e.g. GDB)
	void appendDebuggerMessage(QtMsgType type, const QString& category, const QString& message);
	/// Called when we get an updated cursor from gdb
	/// @see Visualizator::updateStandardInputOutput()
	void updateStandardInputOutput(const GdbItemTree& tree, VisualizationContext context, const QList<ExecutionThread*>& threadsWaitingForIO, int& maxDuration);

  protected slots:
	/// Called when user selects a diagnostic in the tools output list
	void toolsOutputRowChanged(int row);

  protected:
	/// Appends the given diagnostic to the tools output
	void appendDiagnostic(const Diagnostic* diagnostic);
};

#endif // MESSAGESAREA_H
